'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _helpersJs = require('../helpers.js');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _appiumSupport = require('appium-support');

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _logcat = require('../logcat');

var _logcat2 = _interopRequireDefault(_logcat);

var _asyncbox = require('asyncbox');

var _teen_process = require('teen_process');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var SETTINGS_HELPER_ID = 'io.appium.settings';
var WIFI_CONNECTION_SETTING_RECEIVER = SETTINGS_HELPER_ID + '/.receivers.WiFiConnectionSettingReceiver';
var WIFI_CONNECTION_SETTING_ACTION = SETTINGS_HELPER_ID + '.wifi';
var DATA_CONNECTION_SETTING_RECEIVER = SETTINGS_HELPER_ID + '/.receivers.DataConnectionSettingReceiver';
var DATA_CONNECTION_SETTING_ACTION = SETTINGS_HELPER_ID + '.data_connection';
var ANIMATION_SETTING_RECEIVER = SETTINGS_HELPER_ID + '/.receivers.AnimationSettingReceiver';
var ANIMATION_SETTING_ACTION = SETTINGS_HELPER_ID + '.animation';
var LOCATION_SERVICE = SETTINGS_HELPER_ID + '/.LocationService';
var MAX_SHELL_BUFFER_LENGTH = 1000;

var methods = {};

/**
 * Get the path to adb executable amd assign it
 * to this.executable.path and this.binaries.adb properties.
 *
 * @return {string} Full path to adb executable.
 */
methods.getAdbWithCorrectAdbPath = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("adb"));

      case 2:
        this.executable.path = context$1$0.sent;

        this.binaries.adb = this.executable.path;
        return context$1$0.abrupt('return', this.adb);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the full path to aapt tool and assign it to
 * this.binaries.aapt property
 */
methods.initAapt = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("aapt"));

      case 2:
        this.binaries.aapt = context$1$0.sent;

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the full path to zipalign tool and assign it to
 * this.binaries.zipalign property
 */
methods.initZipAlign = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("zipalign"));

      case 2:
        this.binaries.zipalign = context$1$0.sent;

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the API level of the device under test.
 *
 * @return {number} The API level as integer number, for example 21 for
 *                  Android Lollipop. The result of this method is cached, so all the further
 * calls return the same value as the first one.
 */
methods.getApiLevel = function callee$0$0() {
  var strOutput;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (_lodash2['default'].isInteger(this._apiLevel)) {
          context$1$0.next = 13;
          break;
        }

        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getDeviceProperty('ro.build.version.sdk'));

      case 4:
        strOutput = context$1$0.sent;

        this._apiLevel = parseInt(strOutput.trim(), 10);

        if (!isNaN(this._apiLevel)) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('The actual output "' + strOutput + '" cannot be converted to an integer');

      case 8:
        context$1$0.next = 13;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](1);

        _loggerJs2['default'].errorAndThrow('Error getting device API level. Original error: ' + context$1$0.t0.message);

      case 13:
        _loggerJs2['default'].debug('Device API level: ' + this._apiLevel);
        return context$1$0.abrupt('return', this._apiLevel);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 10]]);
};

/**
 * Retrieve the platform version of the device under test.
 *
 * @return {string} The platform version as a string, for example '5.0' for
 * Android Lollipop.
 */
methods.getPlatformVersion = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info("Getting device platform version");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getDeviceProperty('ro.build.version.release'));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _loggerJs2['default'].errorAndThrow('Error getting device platform version. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
};

/**
 * Verify whether a device is connected.
 *
 * @return {boolean} True if at least one device is visible to adb.
 */
methods.isDeviceConnected = function callee$0$0() {
  var devices;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 2:
        devices = context$1$0.sent;
        return context$1$0.abrupt('return', devices.length > 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Recursively create a new folder on the device under test.
 *
 * @param {string} remotePath - The new path to be created.
 * @return {string} mkdir command output.
 */
methods.mkdir = function callee$0$0(remotePath) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['mkdir', '-p', remotePath]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Verify whether the given argument is a
 * valid class name.
 *
 * @param {string} classString - The actual class name to be verified.
 * @return {?Array.<Match>} The result of Regexp.exec operation
 *                          or _null_ if no matches are found.
 */
methods.isValidClass = function (classString) {
  // some.package/some.package.Activity
  return new RegExp(/^[a-zA-Z0-9\./_]+$/).exec(classString);
};

/**
 * Force application to stop on the device under test.
 *
 * @param {string} pkg - The package name to be stopped.
 * @return {string} The output of the corresponding adb command.
 */
methods.forceStop = function callee$0$0(pkg) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['am', 'force-stop', pkg]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Clear the user data of the particular application on the device
 * under test.
 *
 * @param {string} pkg - The package name to be cleared.
 * @return {string} The output of the corresponding adb command.
 */
methods.clear = function callee$0$0(pkg) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'clear', pkg]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Grant all permissions requested by the particular package.
 * This method is only useful on Android 6.0+ and for applications
 * that support components-based permissions setting.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} apk - The path to the actual apk file.
 * @return {string|boolean} The output of the corresponding adb command
 *                          or _false_ if there was an error during command execution.
 */
methods.grantAllPermissions = function callee$0$0(pkg, apk) {
  var apiLevel, targetSdk, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _ret;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;
        targetSdk = null;
        context$1$0.prev = 4;

        if (apk) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.targetSdkVersionUsingPKG(pkg));

      case 8:
        targetSdk = context$1$0.sent;
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.targetSdkVersionFromManifest(apk));

      case 13:
        targetSdk = context$1$0.sent;

      case 14:
        context$1$0.next = 19;
        break;

      case 16:
        context$1$0.prev = 16;
        context$1$0.t0 = context$1$0['catch'](4);

        //avoiding logging error stack, as calling library function would have logged
        _loggerJs2['default'].warn('Ran into problem getting target SDK version; ignoring...');

      case 19:
        if (!(apiLevel >= 23 && targetSdk >= 23)) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((function callee$1$0() {
          var stdout, requestedPermissions, grantedPermissions, permissonsToGrant, cmds, cmdChunk, permission, nextCmd, result, lastError, cmd;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

              case 2:
                stdout = context$2$0.sent;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.getReqPermissions(pkg, stdout));

              case 5:
                requestedPermissions = context$2$0.sent;
                context$2$0.next = 8;
                return _regeneratorRuntime.awrap(this.getGrantedPermissions(pkg, stdout));

              case 8:
                grantedPermissions = context$2$0.sent;
                permissonsToGrant = requestedPermissions.filter(function (x) {
                  return grantedPermissions.indexOf(x) < 0;
                });

                if (permissonsToGrant.length) {
                  context$2$0.next = 13;
                  break;
                }

                _loggerJs2['default'].info(pkg + ' contains no permissions available for granting.');
                return context$2$0.abrupt('return', {
                  v: true
                });

              case 13:
                cmds = [];
                cmdChunk = [];
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 18;

                for (_iterator = _getIterator(permissonsToGrant); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  permission = _step.value;
                  nextCmd = ['pm', 'grant', pkg, permission, ';'];

                  if (nextCmd.join(' ').length + cmdChunk.join(' ').length >= MAX_SHELL_BUFFER_LENGTH) {
                    cmds.push(cmdChunk);
                    cmdChunk = [];
                  }
                  cmdChunk = cmdChunk.concat(nextCmd);
                }
                context$2$0.next = 26;
                break;

              case 22:
                context$2$0.prev = 22;
                context$2$0.t0 = context$2$0['catch'](18);
                _didIteratorError = true;
                _iteratorError = context$2$0.t0;

              case 26:
                context$2$0.prev = 26;
                context$2$0.prev = 27;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 29:
                context$2$0.prev = 29;

                if (!_didIteratorError) {
                  context$2$0.next = 32;
                  break;
                }

                throw _iteratorError;

              case 32:
                return context$2$0.finish(29);

              case 33:
                return context$2$0.finish(26);

              case 34:
                if (cmdChunk.length) {
                  cmds.push(cmdChunk);
                }
                _loggerJs2['default'].debug('Got the following command chunks to execute: ' + cmds);
                result = true;
                lastError = null;
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                context$2$0.prev = 41;
                _iterator2 = _getIterator(cmds);

              case 43:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  context$2$0.next = 61;
                  break;
                }

                cmd = _step2.value;
                context$2$0.prev = 45;
                context$2$0.next = 48;
                return _regeneratorRuntime.awrap(this.shell(cmd));

              case 48:
                context$2$0.t1 = context$2$0.sent;

                if (!context$2$0.t1) {
                  context$2$0.next = 51;
                  break;
                }

                context$2$0.t1 = result;

              case 51:
                result = context$2$0.t1;
                context$2$0.next = 58;
                break;

              case 54:
                context$2$0.prev = 54;
                context$2$0.t2 = context$2$0['catch'](45);

                // this is to give the method a chance to assign all the requested permissions
                // before to quit in case we'd like to ignore the error on the higher level
                lastError = context$2$0.t2;
                result = false;

              case 58:
                _iteratorNormalCompletion2 = true;
                context$2$0.next = 43;
                break;

              case 61:
                context$2$0.next = 67;
                break;

              case 63:
                context$2$0.prev = 63;
                context$2$0.t3 = context$2$0['catch'](41);
                _didIteratorError2 = true;
                _iteratorError2 = context$2$0.t3;

              case 67:
                context$2$0.prev = 67;
                context$2$0.prev = 68;

                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }

              case 70:
                context$2$0.prev = 70;

                if (!_didIteratorError2) {
                  context$2$0.next = 73;
                  break;
                }

                throw _iteratorError2;

              case 73:
                return context$2$0.finish(70);

              case 74:
                return context$2$0.finish(67);

              case 75:
                if (!lastError) {
                  context$2$0.next = 77;
                  break;
                }

                throw lastError;

              case 77:
                return context$2$0.abrupt('return', {
                  v: result
                });

              case 78:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[18, 22, 26, 34], [27,, 29, 33], [41, 63, 67, 75], [45, 54], [68,, 70, 74]]);
        })());

      case 22:
        _ret = context$1$0.sent;

        if (!(typeof _ret === 'object')) {
          context$1$0.next = 25;
          break;
        }

        return context$1$0.abrupt('return', _ret.v);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 16]]);
};

/**
 * Grant single permission for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} permission - The full name of the permission to be granted.
 * @throws {Error} If there was an error while changing permissions.
 */
methods.grantPermission = function callee$0$0(pkg, permission) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'grant', pkg, permission]));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (context$1$0.t0.message.includes("not a changeable permission type")) {
          context$1$0.next = 9;
          break;
        }

        throw context$1$0.t0;

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
};

/**
 * Revoke single permission from the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} permission - The full name of the permission to be revoked.
 * @throws {Error} If there was an error while changing permissions.
 */
methods.revokePermission = function callee$0$0(pkg, permission) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'revoke', pkg, permission]));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (context$1$0.t0.message.includes("not a changeable permission type")) {
          context$1$0.next = 9;
          break;
        }

        throw context$1$0.t0;

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
};

/**
 * Retrieve the list of granted permissions for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} cmdOutput [null] - Optional parameter containing command output of
 *                                    _pm dump_ command. It speeds this method up
 *                                    if present.
 * @return {array} The list of granted permissions or an empty list.
 * @throws {Error} If there was an error while changing permissions.
 */
methods.getGrantedPermissions = function callee$0$0(pkg) {
  var cmdOutput = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var stdout, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = cmdOutput;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 4:
        context$1$0.t0 = context$1$0.sent;

      case 5:
        stdout = context$1$0.t0;
        match = new RegExp(/install permissions:([\s\S]*?)DUMP OF SERVICE activity:/g).exec(stdout);

        if (match) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to get granted permissions');

      case 9:
        return context$1$0.abrupt('return', (match[0].match(/android\.permission\.\w+:\sgranted=true/g) || []).map(function (x) {
          return x.replace(/:\sgranted=true/g, '');
        }));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of denied permissions for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} cmdOutput [null] - Optional parameter containing command output of
 *                                    _pm dump_ command. It speeds this method up
 *                                    if present.
 * @return {array} The list of denied permissions or an empty list.
 */
methods.getDeniedPermissions = function callee$0$0(pkg) {
  var cmdOutput = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var stdout, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = cmdOutput;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 4:
        context$1$0.t0 = context$1$0.sent;

      case 5:
        stdout = context$1$0.t0;
        match = new RegExp(/install permissions:([\s\S]*?)DUMP OF SERVICE activity:/g).exec(stdout);

        if (match) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to get denied permissions');

      case 9:
        return context$1$0.abrupt('return', (match[0].match(/android\.permission\.\w+:\sgranted=false/g) || []).map(function (x) {
          return x.replace(/:\sgranted=false/g, '');
        }));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of requested permissions for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} cmdOutput [null] - Optional parameter containing command output of
 *                                    _pm dump_ command. It speeds this method up
 *                                    if present.
 * @return {array} The list of requested permissions or an empty list.
 */
methods.getReqPermissions = function callee$0$0(pkg) {
  var cmdOutput = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var stdout, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = cmdOutput;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 4:
        context$1$0.t0 = context$1$0.sent;

      case 5:
        stdout = context$1$0.t0;
        match = new RegExp(/requested permissions:([\s\S]*?)install permissions:/g).exec(stdout);

        if (match) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to get requested permissions');

      case 9:
        return context$1$0.abrupt('return', match[0].match(/android\.permission\.\w+/g) || []);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of location providers for the device under test.
 *
 * @return {Array.<String>} The list of available location providers or an empty list.
 */
methods.getLocationProviders = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('secure', 'location_providers_allowed'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', stdout.trim().split(',').map(function (p) {
          return p.trim();
        }).filter(Boolean));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Toggle the state of GPS location provider.
 *
 * @param {boolean} enabled - Whether to enable (true) or disable (false) the GPS provider.
 */
methods.toggleGPSLocationProvider = function callee$0$0(enabled) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setSetting('secure', 'location_providers_allowed', (enabled ? "+" : "-") + 'gps'));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Stop the particular package if it is running and clears its application data.
 *
 * @param {string} pkg - The package name to be processed.
 */
methods.stopAndClear = function callee$0$0(pkg) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.forceStop(pkg));

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.clear(pkg));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Cannot stop and clear ' + pkg + '. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Retrieve the target SDK version for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @return {string} The parsed SDK version.
 */
methods.getTargetSdkUsingPKG = function callee$0$0(pkg) {
  var stdout, targetSdk;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 2:
        stdout = context$1$0.sent;
        targetSdk = new RegExp(/targetSdk=([^\s\s]+)/g).exec(stdout)[1];
        return context$1$0.abrupt('return', targetSdk);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of available input methods (IMEs) for the device under test.
 *
 * @return {Array.<String>} The list of IME names or an empty list.
 */
methods.availableIMEs = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'list', '-a']));

      case 3:
        context$1$0.t0 = context$1$0.sent;
        return context$1$0.abrupt('return', (0, _helpersJs.getIMEListFromOutput)(context$1$0.t0));

      case 7:
        context$1$0.prev = 7;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting available IME\'s. Original error: ' + context$1$0.t1.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Retrieve the list of enabled input methods (IMEs) for the device under test.
 *
 * @return {Array.<String>} The list of enabled IME names or an empty list.
 */
methods.enabledIMEs = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'list']));

      case 3:
        context$1$0.t0 = context$1$0.sent;
        return context$1$0.abrupt('return', (0, _helpersJs.getIMEListFromOutput)(context$1$0.t0));

      case 7:
        context$1$0.prev = 7;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting enabled IME\'s. Original error: ' + context$1$0.t1.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Enable the particular input method on the device under test.
 *
 * @param {string} imeId - One of existing IME ids.
 */
methods.enableIME = function callee$0$0(imeId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'enable', imeId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Disable the particular input method on the device under test.
 *
 * @param {string} imeId - One of existing IME ids.
 */
methods.disableIME = function callee$0$0(imeId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'disable', imeId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the particular input method on the device under test.
 *
 * @param {string} imeId - One of existing IME ids.
 */
methods.setIME = function callee$0$0(imeId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'set', imeId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the default input method on the device under test.
 *
 * @return {string} The name of the default input method.
 */
methods.defaultIME = function callee$0$0() {
  var engine;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getSetting('secure', 'default_input_method'));

      case 3:
        engine = context$1$0.sent;
        return context$1$0.abrupt('return', engine.trim());

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting default IME. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Send the particular keycode to the device under test.
 *
 * @param {string|number} keycode - The actual key code to be sent.
 */
methods.keyevent = function callee$0$0(keycode) {
  var code;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        code = parseInt(keycode, 10);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['input', 'keyevent', code]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send the particular text to the device under test.
 *
 * @param {string} text - The actual text to be sent.
 */
methods.inputText = function callee$0$0(text) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        /* jshint ignore:start */
        // need to escape whitespace and ( ) < > | ; & * \ ~ " '
        text = text.replace(/\\/g, '\\\\').replace(/\(/g, '\(').replace(/\)/g, '\)').replace(/</g, '\<').replace(/>/g, '\>').replace(/\|/g, '\|').replace(/;/g, '\;').replace(/&/g, '\&').replace(/\*/g, '\*').replace(/~/g, '\~').replace(/"/g, '\"').replace(/'/g, "\'").replace(/ /g, '%s');
        /* jshint ignore:end */
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['input', 'text', text]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Clear the active text field on the device under test by sending
 * special keyevents to it.
 *
 * @param {number} length [100] - The maximum length of the text in the field to be cleared.
 */
methods.clearTextField = function callee$0$0() {
  var length = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];
  var args, i;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // assumes that the EditText field already has focus
        _loggerJs2['default'].debug('Clearing up to ' + length + ' characters');

        if (!(length === 0)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return');

      case 3:
        args = ['input', 'keyevent'];

        for (i = 0; i < length; i++) {
          // we cannot know where the cursor is in the text field, so delete both before
          // and after so that we get rid of everything
          // https://developer.android.com/reference/android/view/KeyEvent.html#KEYCODE_DEL
          // https://developer.android.com/reference/android/view/KeyEvent.html#KEYCODE_FORWARD_DEL
          args.push('67', '112');
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send the special keycode to the device under test in order to lock it.
 */
methods.lock = function callee$0$0() {
  var locked;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.isScreenLocked());

      case 2:
        locked = context$1$0.sent;

        if (locked) {
          context$1$0.next = 11;
          break;
        }

        _loggerJs2['default'].debug("Pressing the KEYCODE_POWER button to lock screen");
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.keyevent(26));

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(10, 500, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.isScreenLocked());

              case 2:
                locked = context$2$0.sent;

                if (!locked) {
                  _loggerJs2['default'].errorAndThrow("Waiting for screen to lock.");
                }

              case 4:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }));

      case 9:
        context$1$0.next = 12;
        break;

      case 11:
        _loggerJs2['default'].debug("Screen is already locked. Doing nothing.");

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send the special keycode to the device under test in order to emulate
 * Back button tap.
 */
methods.back = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Pressing the BACK button");
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.keyevent(4));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send the special keycode to the device under test in order to emulate
 * Home button tap.
 */
methods.goToHome = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Pressing the HOME button");
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.keyevent(3));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} the actual path to adb executable.
 */
methods.getAdbPath = function () {
  return this.executable.path;
};

/**
 * Retrieve current screen orientation of the device under test.
 *
 * @return {number} The current orientation encoded as an integer number.
 */
methods.getScreenOrientation = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'input']));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', (0, _helpersJs.getSurfaceOrientation)(stdout));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the screen lock state of the device under test.
 *
 * @return {boolean} True if the device is locked.
 */
methods.isScreenLocked = function callee$0$0() {
  var stdout, dumpsysFile;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'window']));

      case 2:
        stdout = context$1$0.sent;

        if (!process.env.APPIUM_LOG_DUMPSYS) {
          context$1$0.next = 8;
          break;
        }

        dumpsysFile = _path2['default'].resolve(process.cwd(), "dumpsys.log");

        _loggerJs2['default'].debug('Writing dumpsys output to ' + dumpsysFile);
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dumpsysFile, stdout));

      case 8:
        return context$1$0.abrupt('return', (0, _helpersJs.isShowingLockscreen)(stdout) || (0, _helpersJs.isCurrentFocusOnKeyguard)(stdout) || !(0, _helpersJs.isScreenOnFully)(stdout));

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the state of the software keyboard on the device under test.
 *
 * @return {boolean} True if the software keyboard is present.
 */
methods.isSoftKeyboardPresent = function callee$0$0() {
  var stdout, isKeyboardShown, canCloseKeyboard, inputShownMatch, isInputViewShownMatch;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'input_method']));

      case 3:
        stdout = context$1$0.sent;
        isKeyboardShown = false, canCloseKeyboard = false, inputShownMatch = /mInputShown=\w+/gi.exec(stdout);

        if (inputShownMatch && inputShownMatch[0]) {
          isKeyboardShown = inputShownMatch[0].split('=')[1] === 'true';
          isInputViewShownMatch = /mIsInputViewShown=\w+/gi.exec(stdout);

          if (isInputViewShownMatch && isInputViewShownMatch[0]) {
            canCloseKeyboard = isInputViewShownMatch[0].split('=')[1] === 'true';
          }
        }
        return context$1$0.abrupt('return', { isKeyboardShown: isKeyboardShown, canCloseKeyboard: canCloseKeyboard });

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error finding softkeyboard. Original error: ' + context$1$0.t0.message);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
};

/**
 * Send an arbitrary Telnet command to the device under test.
 *
 * @param {string} command - The command to be sent.
 *
 * @return {string} The actual output of the given command.
 */
methods.sendTelnetCommand = function callee$0$0(command) {
  var port;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Sending telnet command to device: ' + command);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getEmulatorPort());

      case 3:
        port = context$1$0.sent;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
          var conn = _net2['default'].createConnection(port, 'localhost'),
              connected = false,
              readyRegex = /^OK$/m,
              dataStream = "",
              res = null;
          conn.on('connect', function () {
            _loggerJs2['default'].debug("Socket connection to device created");
          });
          conn.on('data', function (data) {
            data = data.toString('utf8');
            if (!connected) {
              if (readyRegex.test(data)) {
                connected = true;
                _loggerJs2['default'].debug("Socket connection to device ready");
                conn.write(command + '\n');
              }
            } else {
              dataStream += data;
              if (readyRegex.test(data)) {
                res = dataStream.replace(readyRegex, "").trim();
                res = _lodash2['default'].last(res.trim().split('\n'));
                _loggerJs2['default'].debug('Telnet command got response: ' + res);
                conn.write("quit\n");
              }
            }
          });
          conn.on('error', function (err) {
            // eslint-disable-line promise/prefer-await-to-callbacks
            _loggerJs2['default'].debug('Telnet command error: ' + err.message);
            reject(err);
          });
          conn.on('close', function () {
            if (res === null) {
              reject(new Error("Never got a response from command"));
            } else {
              resolve(res);
            }
          });
        }));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check the state of Airplane mode on the device under test.
 *
 * @return {boolean} True if Airplane mode is enabled.
 */
methods.isAirplaneModeOn = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'airplane_mode_on'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', parseInt(stdout, 10) !== 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of Airplane mode in Settings on the device under test.
 *
 * @param {boolean} on - True to enable the Airplane mode in Settings and false to disable it.
 */
methods.setAirplaneMode = function callee$0$0(on) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setSetting('global', 'airplane_mode_on', on ? 1 : 0));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Broadcast the state of Airplane mode on the device under test.
 * This method should be called after {@link #setAirplaneMode}, otherwise
 * the mode change is not going to be applied for the device.
 *
 * @param {boolean} on - True to broadcast enable and false to broadcast disable.
 */
methods.broadcastAirplaneMode = function callee$0$0(on) {
  var args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['am', 'broadcast', '-a', 'android.intent.action.AIRPLANE_MODE', '--ez', 'state', on ? 'true' : 'false'];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check the state of WiFi on the device under test.
 *
 * @return {boolean} True if WiFi is enabled.
 */
methods.isWifiOn = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'wifi_on'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', parseInt(stdout, 10) !== 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of WiFi on the device under test.
 *
 * @param {boolean} on - True to enable and false to disable it.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setWifiState = function callee$0$0(on) {
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!isEmulator) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['svc', 'wifi', on ? 'enable' : 'disable']));

      case 3:
        context$1$0.next = 7;
        break;

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', WIFI_CONNECTION_SETTING_ACTION, '-n', WIFI_CONNECTION_SETTING_RECEIVER, '--es', 'setstatus', on ? 'enable' : 'disable']));

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check the state of Data transfer on the device under test.
 *
 * @return {boolean} True if Data transfer is enabled.
 */
methods.isDataOn = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'mobile_data'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', parseInt(stdout, 10) !== 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of Data transfer on the device under test.
 *
 * @param {boolean} on - True to enable and false to disable it.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setDataState = function callee$0$0(on) {
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!isEmulator) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['svc', 'data', on ? 'enable' : 'disable']));

      case 3:
        context$1$0.next = 7;
        break;

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', DATA_CONNECTION_SETTING_ACTION, '-n', DATA_CONNECTION_SETTING_RECEIVER, '--es', 'setstatus', on ? 'enable' : 'disable']));

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of WiFi and/or Data transfer on the device under test.
 *
 * @param {boolean} wifi - True to enable and false to disable WiFi.
 * @param {boolean} data - True to enable and false to disable Data transfer.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setWifiAndData = function callee$0$0(_ref) {
  var wifi = _ref.wifi;
  var data = _ref.data;
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!_lodash2['default'].isUndefined(wifi)) {
          this.setWifiState(wifi, isEmulator);
        }
        if (!_lodash2['default'].isUndefined(data)) {
          this.setDataState(data, isEmulator);
        }

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of animation on the device under test.
 * Animation on the device is controlled by the following global properties:
 * [ANIMATOR_DURATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#ANIMATOR_DURATION_SCALE},
 * [TRANSITION_ANIMATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#TRANSITION_ANIMATION_SCALE},
 * [WINDOW_ANIMATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#WINDOW_ANIMATION_SCALE}.
 * This method sets all this properties to 0.0 to disable (1.0 to enable) animation.
 *
 * Turning off animation might be useful to improve stability
 * and reduce tests execution time.
 *
 * @param {boolean} on - True to enable and false to disable it.
 */
methods.setAnimationState = function callee$0$0(on) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', ANIMATION_SETTING_ACTION, '-n', ANIMATION_SETTING_RECEIVER, '--es', 'setstatus', on ? 'enable' : 'disable']));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check the state of animation on the device under test.
 *
 * @return {boolean} True if at least one of animation scale settings
 *                   is not equal to '0.0'.
 */
methods.isAnimationOn = function callee$0$0() {
  var animator_duration_scale, transition_animation_scale, window_animation_scale;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'animator_duration_scale'));

      case 2:
        animator_duration_scale = context$1$0.sent;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'transition_animation_scale'));

      case 5:
        transition_animation_scale = context$1$0.sent;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'window_animation_scale'));

      case 8:
        window_animation_scale = context$1$0.sent;
        return context$1$0.abrupt('return', _lodash2['default'].some([animator_duration_scale, transition_animation_scale, window_animation_scale], function (setting) {
          return setting !== '0.0';
        }));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @typedef {Object} Location
 * @property {float|string} longitude - Valid longitude value.
 * @property {float|string} latitude - Valid latitude value.
 */

/**
 * Emulate geolocation coordinates on the device under test.
 *
 * @param {Location} location - Location object.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setGeoLocation = function callee$0$0(location) {
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var longitude, latitude;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        longitude = parseFloat(location.longitude);

        if (isNaN(longitude)) {
          _loggerJs2['default'].errorAndThrow('location.longitude is expected to be a valid float number. \'' + location.longitude + '\' is given instead');
        }
        longitude = '' + _lodash2['default'].ceil(longitude, 5);
        latitude = parseFloat(location.latitude);

        if (isNaN(latitude)) {
          _loggerJs2['default'].errorAndThrow('location.latitude is expected to be a valid float number. \'' + location.latitude + '\' is given instead');
        }
        latitude = '' + _lodash2['default'].ceil(latitude, 5);

        if (!isEmulator) {
          context$1$0.next = 12;
          break;
        }

        this.resetTelnetAuthToken();
        this.adbExec(['emu', 'geo', 'fix', longitude, latitude]);
        // A workaround for https://code.google.com/p/android/issues/detail?id=206180
        this.adbExec(['emu', 'geo', 'fix', longitude.replace('.', ','), latitude.replace('.', ',')]);
        context$1$0.next = 15;
        break;

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(this.shell(['am', 'startservice', '-e', 'longitude', longitude, '-e', 'latitude', latitude, LOCATION_SERVICE]));

      case 14:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Forcefully recursively remove a path on the device under test.
 * Be careful while calling this method.
 *
 * @param {string} path - The path to be removed recursively.
 */
methods.rimraf = function callee$0$0(path) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['rm', '-rf', path]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send a file to the device under test.
 *
 * @param {string} localPath - The path to the file on the local file system.
 * @param {string} remotePath - The destination path on the remote device.
 * @param {object} opts - Additional options mapping. See
 *                        https://github.com/appium/node-teen_process,
 *                        _exec_ method options, for more information about available
 *                        options.
 */
methods.push = function callee$0$0(localPath, remotePath, opts) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(['push', localPath, remotePath], opts));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Receive a file from the device under test.
 *
 * @param {string} remotePath - The source path on the remote device.
 * @param {string} localPath - The destination path to the file on the local file system.
 */
methods.pull = function callee$0$0(remotePath, localPath) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(['pull', remotePath, localPath], { timeout: 60000 }));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check whether the process with the particular name is running on the device
 * under test.
 *
 * @param {string} processName - The name of the process to be checked.
 * @return {boolean} True if the given process is running.
 * @throws {error} If the given process name is not a valid class name.
 */
methods.processExists = function callee$0$0(processName) {
  var stdout, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, line, pkgColumn;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        if (this.isValidClass(processName)) {
          context$1$0.next = 3;
          break;
        }

        throw new Error('Invalid process name: ' + processName);

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell("ps"));

      case 5:
        stdout = context$1$0.sent;
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 9;
        _iterator3 = _getIterator(stdout.split(/\r?\n/));

      case 11:
        if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
          context$1$0.next = 20;
          break;
        }

        line = _step3.value;

        line = line.trim().split(/\s+/);
        pkgColumn = line[line.length - 1];

        if (!(pkgColumn && pkgColumn.indexOf(processName) !== -1)) {
          context$1$0.next = 17;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 17:
        _iteratorNormalCompletion3 = true;
        context$1$0.next = 11;
        break;

      case 20:
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](9);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 26:
        context$1$0.prev = 26;
        context$1$0.prev = 27;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 29:
        context$1$0.prev = 29;

        if (!_didIteratorError3) {
          context$1$0.next = 32;
          break;
        }

        throw _iteratorError3;

      case 32:
        return context$1$0.finish(29);

      case 33:
        return context$1$0.finish(26);

      case 34:
        return context$1$0.abrupt('return', false);

      case 37:
        context$1$0.prev = 37;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error finding if process exists. Original error: ' + context$1$0.t1.message);

      case 40:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 37], [9, 22, 26, 34], [27,, 29, 33]]);
};

/**
 * Get TCP port forwarding with adb on the device under test.
 * @return {Array.<String>} The output of the corresponding adb command. An array contains each forwarding line of output
 */
methods.getForwardList = function callee$0$0() {
  var connections;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('List forwarding ports');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', '--list']));

      case 3:
        connections = context$1$0.sent;
        return context$1$0.abrupt('return', connections.split('\n'));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Setup TCP port forwarding with adb on the device under test.
 *
 * @param {string|number} systemPort - The number of the local system port.
 * @param {string|number} devicePort - The number of the remote device port.
 */
methods.forwardPort = function callee$0$0(systemPort, devicePort) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Forwarding system: ' + systemPort + ' to device: ' + devicePort);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', 'tcp:' + systemPort, 'tcp:' + devicePort]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Remove TCP port forwarding with adb on the device under test. The forwarding
 * for the given port should be setup with {@link #forwardPort} first.
 *
 * @param {string|number} systemPort - The number of the local system port
 *                                     to remove forwarding on.
 */
methods.removePortForward = function callee$0$0(systemPort) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Removing forwarded port socket connection: ' + systemPort + ' ');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', '--remove', 'tcp:' + systemPort]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Setup TCP port forwarding with adb on the device under test. The difference
 * between {@link #forwardPort} is that this method does setup for an abstract
 * local port.
 *
 * @param {string|number} systemPort - The number of the local system port.
 * @param {string|number} devicePort - The number of the remote device port.
 */
methods.forwardAbstractPort = function callee$0$0(systemPort, devicePort) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Forwarding system: ' + systemPort + ' to abstract device: ' + devicePort);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', 'tcp:' + systemPort, 'localabstract:' + devicePort]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute ping shell command on the device under test.
 *
 * @return {boolean} True if the command output contains 'ping' substring.
 * @throws {error} If there was an error while executing 'ping' command on the
 *                 device under test.
 */
methods.ping = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(["echo", "ping"]));

      case 2:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf("ping") === 0)) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 5:
        throw new Error('ADB ping failed, returned ' + stdout);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Restart the device under test using adb commands.
 *
 * @throws {error} If start fails.
 */
methods.restart = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.stopLogcat());

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.restartAdb());

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.waitForDevice(60));

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.startLogcat());

      case 9:
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Restart failed. Orginial error: ' + context$1$0.t0.message);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 11]]);
};

/**
 * Start the logcat process to gather logs.
 *
 * @throws {error} If restart fails.
 */
methods.startLogcat = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (this.logcat !== null) {
          _loggerJs2['default'].errorAndThrow("Trying to start logcat capture but it's already started!");
        }
        this.logcat = new _logcat2['default']({
          adb: this.executable,
          debug: false,
          debugTrace: false
        });
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.logcat.startCapture());

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Stop the active logcat process which gathers logs.
 * The call will be ignored if no logcat process is running.
 */
methods.stopLogcat = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(this.logcat !== null)) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.logcat.stopCapture());

      case 3:
        this.logcat = null;

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the output from the currently running logcat process.
 * The logcat process should be executed by {2link #startLogcat} method.
 *
 * @return {string} The collected logcat output.
 * @throws {error} If logcat process is not running.
 */
methods.getLogcatLogs = function () {
  if (this.logcat === null) {
    _loggerJs2['default'].errorAndThrow("Can't get logcat logs since logcat hasn't started");
  }
  return this.logcat.getLogs();
};

/**
 * Get the list of process ids for the particular process on the device under test.
 *
 * @param {string} name - The part of process name.
 * @return {Array.<number>} The list of matched process IDs or an empty list.
 */
methods.getPIDsByName = function callee$0$0(name) {
  var stdout, pids, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, line, match;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Getting all processes with ' + name);
        context$1$0.prev = 1;

        // ps <comm> where comm is last 15 characters of package name
        if (name.length > 15) {
          name = name.substr(name.length - 15);
        }
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell(["ps"]));

      case 5:
        stdout = context$1$0.sent.trim();
        pids = [];
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 10;
        _iterator4 = _getIterator(stdout.split("\n"));

      case 12:
        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
          context$1$0.next = 24;
          break;
        }

        line = _step4.value;

        if (!(line.indexOf(name) !== -1)) {
          context$1$0.next = 21;
          break;
        }

        match = /[^\t ]+[\t ]+([0-9]+)/.exec(line);

        if (!match) {
          context$1$0.next = 20;
          break;
        }

        pids.push(parseInt(match[1], 10));
        context$1$0.next = 21;
        break;

      case 20:
        throw new Error('Could not extract PID from ps output: ' + line);

      case 21:
        _iteratorNormalCompletion4 = true;
        context$1$0.next = 12;
        break;

      case 24:
        context$1$0.next = 30;
        break;

      case 26:
        context$1$0.prev = 26;
        context$1$0.t0 = context$1$0['catch'](10);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 30:
        context$1$0.prev = 30;
        context$1$0.prev = 31;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 33:
        context$1$0.prev = 33;

        if (!_didIteratorError4) {
          context$1$0.next = 36;
          break;
        }

        throw _iteratorError4;

      case 36:
        return context$1$0.finish(33);

      case 37:
        return context$1$0.finish(30);

      case 38:
        return context$1$0.abrupt('return', pids);

      case 41:
        context$1$0.prev = 41;
        context$1$0.t1 = context$1$0['catch'](1);

        _loggerJs2['default'].errorAndThrow('Unable to get pids for ' + name + '. Orginial error: ' + context$1$0.t1.message);

      case 44:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 41], [10, 26, 30, 38], [31,, 33, 37]]);
};

/**
 * Get the list of process ids for the particular process on the device under test.
 *
 * @param {string} name - The part of process name.
 * @return {Array.<number>} The list of matched process IDs or an empty list.
 */
methods.killProcessesByName = function callee$0$0(name) {
  var pids, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, pid;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug('Attempting to kill all ' + name + ' processes');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getPIDsByName(name));

      case 4:
        pids = context$1$0.sent;

        if (!(pids.length < 1)) {
          context$1$0.next = 8;
          break;
        }

        _loggerJs2['default'].info('No ' + name + ' process found to kill, continuing...');
        return context$1$0.abrupt('return');

      case 8:
        _iteratorNormalCompletion5 = true;
        _didIteratorError5 = false;
        _iteratorError5 = undefined;
        context$1$0.prev = 11;
        _iterator5 = _getIterator(pids);

      case 13:
        if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
          context$1$0.next = 20;
          break;
        }

        pid = _step5.value;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(this.killProcessByPID(pid));

      case 17:
        _iteratorNormalCompletion5 = true;
        context$1$0.next = 13;
        break;

      case 20:
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](11);
        _didIteratorError5 = true;
        _iteratorError5 = context$1$0.t0;

      case 26:
        context$1$0.prev = 26;
        context$1$0.prev = 27;

        if (!_iteratorNormalCompletion5 && _iterator5['return']) {
          _iterator5['return']();
        }

      case 29:
        context$1$0.prev = 29;

        if (!_didIteratorError5) {
          context$1$0.next = 32;
          break;
        }

        throw _iteratorError5;

      case 32:
        return context$1$0.finish(29);

      case 33:
        return context$1$0.finish(26);

      case 34:
        context$1$0.next = 39;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Unable to kill ' + name + ' processes. Original error: ' + context$1$0.t1.message);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 36], [11, 22, 26, 34], [27,, 29, 33]]);
};

/**
 * Kill the particular process on the device under test.
 *
 * @param {string|number} pid - The ID of the process to be killed.
 * @return {string} Kill command stdout.
 * @throws {Error} If the process with given ID is not present or cannot be killed.
 */
methods.killProcessByPID = function callee$0$0(pid) {
  var timeoutMs, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Attempting to kill process ' + pid);
        // Just to check if the process exists and throw an exception otherwise
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['kill', '-0', pid]));

      case 3:
        timeoutMs = 1000;
        stdout = undefined;
        context$1$0.prev = 5;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.shell(['kill', pid]));

              case 3:
                stdout = context$2$0.sent;
                return context$2$0.abrupt('return', false);

              case 7:
                context$2$0.prev = 7;
                context$2$0.t0 = context$2$0['catch'](0);
                return context$2$0.abrupt('return', true);

              case 10:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[0, 7]]);
        }, { waitMs: timeoutMs, intervalMs: 300 }));

      case 8:
        context$1$0.next = 16;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](5);

        _loggerJs2['default'].warn('Cannot kill process ' + pid + ' in ' + timeoutMs + ' ms. Trying to force kill...');
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.shell(['kill', '-9', pid]));

      case 15:
        stdout = context$1$0.sent;

      case 16:
        return context$1$0.abrupt('return', stdout);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 10]]);
};

/**
 * Broadcast process killing on the device under test.
 *
 * @param {string} intent - The name of the intent to broadcast to.
 * @param {string} processName - The name of the killed process.
 * @throws {error} If the process was not killed.
 */
methods.broadcastProcessEnd = function callee$0$0(intent, processName) {
  var start, timeoutMs;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // start the broadcast without waiting for it to finish.
        this.broadcast(intent);
        // wait for the process to end
        start = Date.now();
        timeoutMs = 40000;
        context$1$0.prev = 3;

      case 4:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 14;
          break;
        }

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.processExists(processName));

      case 7:
        if (!context$1$0.sent) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(400));

      case 10:
        return context$1$0.abrupt('continue', 4);

      case 11:
        return context$1$0.abrupt('return');

      case 14:
        throw new Error('Process never died within ' + timeoutMs + ' ms');

      case 17:
        context$1$0.prev = 17;
        context$1$0.t0 = context$1$0['catch'](3);

        _loggerJs2['default'].errorAndThrow('Unable to broadcast process end. Original error: ' + context$1$0.t0.message);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 17]]);
};

/**
 * Broadcast a message to the given intent.
 *
 * @param {string} intent - The name of the intent to broadcast to.
 * @throws {error} If intent name is not a valid class name.
 */
methods.broadcast = function callee$0$0(intent) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.isValidClass(intent)) {
          _loggerJs2['default'].errorAndThrow('Invalid intent ' + intent);
        }
        _loggerJs2['default'].debug('Broadcasting: ' + intent);
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', intent]));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Kill Android instruments if they are currently running.
 */
methods.endAndroidCoverage = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(this.instrumentProc && this.instrumentProc.isRunning)) {
          context$1$0.next = 3;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.instrumentProc.stop());

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Instrument the particular activity.
 *
 * @param {string} pkg - The name of the package to be instrumented.
 * @param {string} activity - The name of the main activity in this package.
 * @param {string} instrumentWith - The name of the package to instrument
 *                                  the activity with.
 * @throws {error} If any exception is reported by adb shell.
 */
methods.instrument = function callee$0$0(pkg, activity, instrumentWith) {
  var pkgActivity, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (activity[0] !== ".") {
          pkg = "";
        }
        pkgActivity = (pkg + activity).replace(/\.+/g, '.');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['am', 'instrument', '-e', 'main_activity', pkgActivity, instrumentWith]));

      case 4:
        stdout = context$1$0.sent;

        if (stdout.indexOf("Exception") !== -1) {
          _loggerJs2['default'].errorAndThrow('Unknown exception during instrumentation. ' + ('Original error ' + stdout.split("\n")[0]));
        }

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Collect Android coverage by instrumenting the particular activity.
 *
 * @param {string} instrumentClass - The name of the instrumentation class.
 * @param {string} waitPkg - The name of the package to be instrumented.
 * @param {string} waitActivity - The name of the main activity in this package.
 *
 * @return {promise} The promise is successfully resolved if the instrumentation starts
 *                   without errors.
 */
methods.androidCoverage = function callee$0$0(instrumentClass, waitPkg, waitActivity) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.isValidClass(instrumentClass)) {
          _loggerJs2['default'].errorAndThrow('Invalid class ' + instrumentClass);
        }
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$1$0(resolve, reject) {
          var args;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                args = this.executable.defaultArgs.concat(['shell', 'am', 'instrument', '-e', 'coverage', 'true', '-w']).concat([instrumentClass]);

                _loggerJs2['default'].debug('Collecting coverage data with: ' + [this.executable.path].concat(args).join(' '));
                context$2$0.prev = 2;

                // am instrument runs for the life of the app process.
                this.instrumentProc = new _teen_process.SubProcess(this.executable.path, args);
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap(this.instrumentProc.start(0));

              case 6:
                this.instrumentProc.on('output', function (stdout, stderr) {
                  if (stderr) {
                    reject(new Error('Failed to run instrumentation. Original error: ' + stderr));
                  }
                });
                context$2$0.next = 9;
                return _regeneratorRuntime.awrap(this.waitForActivity(waitPkg, waitActivity));

              case 9:
                resolve();
                context$2$0.next = 15;
                break;

              case 12:
                context$2$0.prev = 12;
                context$2$0.t0 = context$2$0['catch'](2);

                reject(new Error('Android coverage failed. Original error: ' + context$2$0.t0.message));

              case 15:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4, [[2, 12]]);
        }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the particular property of the device under test.
 *
 * @param {string} property - The name of the property. This name should
 *                            be known to _adb shell getprop_ tool.
 *
 * @return {string} The value of the given property.
 */
methods.getDeviceProperty = function callee$0$0(property) {
  var stdout, val;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['getprop', property]));

      case 2:
        stdout = context$1$0.sent;
        val = stdout.trim();

        _loggerJs2['default'].debug('Current device property \'' + property + '\': ' + val);
        return context$1$0.abrupt('return', val);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the particular property of the device under test.
 *
 * @param {string} property - The name of the property. This name should
 *                            be known to _adb shell setprop_ tool.
 * @param {string} val - The new property value.
 *
 * @throws {error} If _setprop_ utility fails to change property value.
 */
methods.setDeviceProperty = function callee$0$0(prop, val) {
  var apiLevel, err;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;

        if (!(apiLevel >= 26)) {
          context$1$0.next = 7;
          break;
        }

        _loggerJs2['default'].debug('Running adb root, Android O needs adb to be rooted to setDeviceProperty');
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.root());

      case 7:
        _loggerJs2['default'].debug('Setting device property \'' + prop + '\' to \'' + val + '\'');
        err = undefined;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.shell(['setprop', prop, val]));

      case 12:
        context$1$0.next = 17;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](9);

        err = context$1$0.t0;

      case 17:
        if (!(apiLevel >= 26)) {
          context$1$0.next = 21;
          break;
        }

        _loggerJs2['default'].debug('Removing adb root for setDeviceProperty');
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.unroot());

      case 21:
        if (!err) {
          context$1$0.next = 23;
          break;
        }

        throw err;

      case 23:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 14]]);
};

/**
 * @return {string} Current system language on the device under test.
 */
// eslint-disable-line curly
methods.getDeviceSysLanguage = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("persist.sys.language"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the new system language on the device under test.
 *
 * @param {string} language - The new language value.
 */
methods.setDeviceSysLanguage = function callee$0$0(language) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceProperty("persist.sys.language", language.toLowerCase()));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current country name on the device under test.
 */
methods.getDeviceSysCountry = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("persist.sys.country"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the new system country on the device under test.
 *
 * @param {string} country - The new country value.
 */
methods.setDeviceSysCountry = function callee$0$0(country) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceProperty("persist.sys.country", country.toUpperCase()));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current system locale name on the device under test.
 */
methods.getDeviceSysLocale = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("persist.sys.locale"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the new system locale on the device under test.
 *
 * @param {string} locale - The new locale value.
 */
methods.setDeviceSysLocale = function callee$0$0(locale) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceProperty("persist.sys.locale", locale));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current product language name on the device under test.
 */
methods.getDeviceProductLanguage = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.locale.language"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current product country name on the device under test.
 */
methods.getDeviceProductCountry = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.locale.region"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current product locale name on the device under test.
 */
methods.getDeviceProductLocale = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.locale"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} The model name of the device under test.
 */
methods.getModel = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.model"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} The manufacturer name of the device under test.
 */
methods.getManufacturer = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.manufacturer"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the current screen size.
 *
 * @return {string} Device screen size as string in format 'WxH' or
 *                  _null_ if it cannot be determined.
 */
methods.getScreenSize = function callee$0$0() {
  var stdout, size;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['wm', 'size']));

      case 2:
        stdout = context$1$0.sent;
        size = new RegExp(/Physical size: ([^\r?\n]+)*/g).exec(stdout);

        if (!(size && size.length >= 2)) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', size[1].trim());

      case 6:
        return context$1$0.abrupt('return', null);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Setup HTTP proxy in device settings.
 *
 * @param {string} proxyHost - The host name of the proxy.
 * @param {string|number} proxyPort - The port number to be set.
 */
methods.setHttpProxy = function callee$0$0(proxyHost, proxyPort) {
  var proxy;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        proxy = proxyHost + ':' + proxyPort;

        if (_lodash2['default'].isUndefined(proxyHost)) {
          _loggerJs2['default'].errorAndThrow('Call to setHttpProxy method with undefined proxy_host: ' + proxy);
        }
        if (_lodash2['default'].isUndefined(proxyPort)) {
          _loggerJs2['default'].errorAndThrow('Call to setHttpProxy method with undefined proxy_port ' + proxy);
        }
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.setSetting('global', 'http_proxy', proxy));

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.setSetting('secure', 'http_proxy', proxy));

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.setSetting('system', 'http_proxy', proxy));

      case 9:
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.setSetting('system', 'global_http_proxy_host', proxyHost));

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.setSetting('system', 'global_http_proxy_port', proxyPort));

      case 13:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set device property.
 * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
 *
 * @param {string} namespace - one of {system, secure, global}, case-insensitive.
 * @param {string} setting - property name.
 * @param {string|number} value - property value.
 * @return {string} command output.
 */
methods.setSetting = function callee$0$0(namespace, setting, value) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['settings', 'put', namespace, setting, value]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get device property.
 * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
 *
 * @param {string} namespace - one of {system, secure, global}, case-insensitive.
 * @param {string} setting - property name.
 * @return {string} property value.
 */
methods.getSetting = function callee$0$0(namespace, setting) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['settings', 'get', namespace, setting]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

exports['default'] = methods;
module.exports = exports['default'];

/**
 * If apk not provided, considering apk already installed on the device
 * and fetching targetSdk using package name.
 */

/**
 * If the device is running Android 6.0(API 23) or higher, and your app's target SDK is 23 or higher:
 * The app has to list the permissions in the manifest.
 * refer: https://developer.android.com/training/permissions/requesting.html
 */

// As it consumes more time for granting each permission,
// trying to grant all permission by forming equivalent command.
// Also, it is necessary to split long commands into chunks, since the maximum length of
// adb shell buffer is limited

// keycode must be an int.

// wait for the screen to lock

// optional debugging
// if the method is not working, turn it on and send us the output

// pull folder can take more time, increasing time out to 60 secs

// kill returns non-zero code if the process is already killed

// cool down
// Fix pkg..activity error
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9hZGItY29tbWFuZHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3dCQUFnQixjQUFjOzs7O3lCQUV5QixlQUFlOztvQkFDckQsTUFBTTs7OztzQkFDVCxRQUFROzs7OzZCQUNILGdCQUFnQjs7bUJBQ25CLEtBQUs7Ozs7c0JBQ0YsV0FBVzs7Ozt3QkFDeUIsVUFBVTs7NEJBQ3RDLGNBQWM7O3dCQUMzQixVQUFVOzs7O0FBRXhCLElBQU0sa0JBQWtCLEdBQUcsb0JBQW9CLENBQUM7QUFDaEQsSUFBTSxnQ0FBZ0MsR0FBTSxrQkFBa0IsOENBQTJDLENBQUM7QUFDMUcsSUFBTSw4QkFBOEIsR0FBTSxrQkFBa0IsVUFBTyxDQUFDO0FBQ3BFLElBQU0sZ0NBQWdDLEdBQU0sa0JBQWtCLDhDQUEyQyxDQUFDO0FBQzFHLElBQU0sOEJBQThCLEdBQU0sa0JBQWtCLHFCQUFrQixDQUFDO0FBQy9FLElBQU0sMEJBQTBCLEdBQU0sa0JBQWtCLHlDQUFzQyxDQUFDO0FBQy9GLElBQU0sd0JBQXdCLEdBQU0sa0JBQWtCLGVBQVksQ0FBQztBQUNuRSxJQUFNLGdCQUFnQixHQUFNLGtCQUFrQixzQkFBbUIsQ0FBQztBQUNsRSxJQUFNLHVCQUF1QixHQUFHLElBQUksQ0FBQzs7QUFFckMsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDOzs7Ozs7OztBQVFqQixPQUFPLENBQUMsd0JBQXdCLEdBQUc7Ozs7O3lDQUNKLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7OztBQUF6RCxZQUFJLENBQUMsVUFBVSxDQUFDLElBQUk7O0FBQ3BCLFlBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDOzRDQUNsQyxJQUFJLENBQUMsR0FBRzs7Ozs7OztDQUNoQixDQUFDOzs7Ozs7QUFNRixPQUFPLENBQUMsUUFBUSxHQUFHOzs7Ozt5Q0FDVSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFB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QUFDOztxQkFFYSxPQUFPIiwiZmlsZSI6ImxpYi90b29scy9hZGItY29tbWFuZHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBnZXRJTUVMaXN0RnJvbU91dHB1dCwgaXNTaG93aW5nTG9ja3NjcmVlbiwgaXNDdXJyZW50Rm9jdXNPbktleWd1YXJkLFxuICAgICAgICAgZ2V0U3VyZmFjZU9yaWVudGF0aW9uLCBpc1NjcmVlbk9uRnVsbHkgfSBmcm9tICcuLi9oZWxwZXJzLmpzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZzIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IG5ldCBmcm9tICduZXQnO1xuaW1wb3J0IExvZ2NhdCBmcm9tICcuLi9sb2djYXQnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcblxuY29uc3QgU0VUVElOR1NfSEVMUEVSX0lEID0gJ2lvLmFwcGl1bS5zZXR0aW5ncyc7XG5jb25zdCBXSUZJX0NPTk5FQ1RJT05fU0VUVElOR19SRUNFSVZFUiA9IGAke1NFVFRJTkdTX0hFTFBFUl9JRH0vLnJlY2VpdmVycy5XaUZpQ29ubmVjdGlvblNldHRpbmdSZWNlaXZlcmA7XG5jb25zdCBXSUZJX0NPTk5FQ1RJT05fU0VUVElOR19BQ1RJT04gPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9LndpZmlgO1xuY29uc3QgREFUQV9DT05ORUNUSU9OX1NFVFRJTkdfUkVDRUlWRVIgPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9Ly5yZWNlaXZlcnMuRGF0YUNvbm5lY3Rpb25TZXR0aW5nUmVjZWl2ZXJgO1xuY29uc3QgREFUQV9DT05ORUNUSU9OX1NFVFRJTkdfQUNUSU9OID0gYCR7U0VUVElOR1NfSEVMUEVSX0lEfS5kYXRhX2Nvbm5lY3Rpb25gO1xuY29uc3QgQU5JTUFUSU9OX1NFVFRJTkdfUkVDRUlWRVIgPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9Ly5yZWNlaXZlcnMuQW5pbWF0aW9uU2V0dGluZ1JlY2VpdmVyYDtcbmNvbnN0IEFOSU1BVElPTl9TRVRUSU5HX0FDVElPTiA9IGAke1NFVFRJTkdTX0hFTFBFUl9JRH0uYW5pbWF0aW9uYDtcbmNvbnN0IExPQ0FUSU9OX1NFUlZJQ0UgPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9Ly5Mb2NhdGlvblNlcnZpY2VgO1xuY29uc3QgTUFYX1NIRUxMX0JVRkZFUl9MRU5HVEggPSAxMDAwO1xuXG5sZXQgbWV0aG9kcyA9IHt9O1xuXG4vKipcbiAqIEdldCB0aGUgcGF0aCB0byBhZGIgZXhlY3V0YWJsZSBhbWQgYXNzaWduIGl0XG4gKiB0byB0aGlzLmV4ZWN1dGFibGUucGF0aCBhbmQgdGhpcy5iaW5hcmllcy5hZGIgcHJvcGVydGllcy5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byBhZGIgZXhlY3V0YWJsZS5cbiAqL1xubWV0aG9kcy5nZXRBZGJXaXRoQ29ycmVjdEFkYlBhdGggPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZXhlY3V0YWJsZS5wYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKFwiYWRiXCIpO1xuICB0aGlzLmJpbmFyaWVzLmFkYiA9IHRoaXMuZXhlY3V0YWJsZS5wYXRoO1xuICByZXR1cm4gdGhpcy5hZGI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZnVsbCBwYXRoIHRvIGFhcHQgdG9vbCBhbmQgYXNzaWduIGl0IHRvXG4gKiB0aGlzLmJpbmFyaWVzLmFhcHQgcHJvcGVydHlcbiAqL1xubWV0aG9kcy5pbml0QWFwdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iaW5hcmllcy5hYXB0ID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKFwiYWFwdFwiKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmdWxsIHBhdGggdG8gemlwYWxpZ24gdG9vbCBhbmQgYXNzaWduIGl0IHRvXG4gKiB0aGlzLmJpbmFyaWVzLnppcGFsaWduIHByb3BlcnR5XG4gKi9cbm1ldGhvZHMuaW5pdFppcEFsaWduID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0aGlzLmJpbmFyaWVzLnppcGFsaWduID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKFwiemlwYWxpZ25cIik7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBBUEkgbGV2ZWwgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIEFQSSBsZXZlbCBhcyBpbnRlZ2VyIG51bWJlciwgZm9yIGV4YW1wbGUgMjEgZm9yXG4gKiAgICAgICAgICAgICAgICAgIEFuZHJvaWQgTG9sbGlwb3AuIFRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgY2FjaGVkLCBzbyBhbGwgdGhlIGZ1cnRoZXJcbiAqIGNhbGxzIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZmlyc3Qgb25lLlxuICovXG5tZXRob2RzLmdldEFwaUxldmVsID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAoIV8uaXNJbnRlZ2VyKHRoaXMuX2FwaUxldmVsKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJPdXRwdXQgPSBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdyby5idWlsZC52ZXJzaW9uLnNkaycpO1xuICAgICAgdGhpcy5fYXBpTGV2ZWwgPSBwYXJzZUludChzdHJPdXRwdXQudHJpbSgpLCAxMCk7XG4gICAgICBpZiAoaXNOYU4odGhpcy5fYXBpTGV2ZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGFjdHVhbCBvdXRwdXQgXCIke3N0ck91dHB1dH1cIiBjYW5ub3QgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXJgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgZ2V0dGluZyBkZXZpY2UgQVBJIGxldmVsLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIGxvZy5kZWJ1ZyhgRGV2aWNlIEFQSSBsZXZlbDogJHt0aGlzLl9hcGlMZXZlbH1gKTtcbiAgcmV0dXJuIHRoaXMuX2FwaUxldmVsO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgcGxhdGZvcm0gdmVyc2lvbiBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGxhdGZvcm0gdmVyc2lvbiBhcyBhIHN0cmluZywgZm9yIGV4YW1wbGUgJzUuMCcgZm9yXG4gKiBBbmRyb2lkIExvbGxpcG9wLlxuICovXG5tZXRob2RzLmdldFBsYXRmb3JtVmVyc2lvbiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmluZm8oXCJHZXR0aW5nIGRldmljZSBwbGF0Zm9ybSB2ZXJzaW9uXCIpO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdyby5idWlsZC52ZXJzaW9uLnJlbGVhc2UnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBnZXR0aW5nIGRldmljZSBwbGF0Zm9ybSB2ZXJzaW9uLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgYSBkZXZpY2UgaXMgY29ubmVjdGVkLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYXQgbGVhc3Qgb25lIGRldmljZSBpcyB2aXNpYmxlIHRvIGFkYi5cbiAqL1xubWV0aG9kcy5pc0RldmljZUNvbm5lY3RlZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgcmV0dXJuIGRldmljZXMubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY3JlYXRlIGEgbmV3IGZvbGRlciBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgbmV3IHBhdGggdG8gYmUgY3JlYXRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gbWtkaXIgY29tbWFuZCBvdXRwdXQuXG4gKi9cbm1ldGhvZHMubWtkaXIgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5zaGVsbChbJ21rZGlyJywgJy1wJywgcmVtb3RlUGF0aF0pO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgd2hldGhlciB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYVxuICogdmFsaWQgY2xhc3MgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NTdHJpbmcgLSBUaGUgYWN0dWFsIGNsYXNzIG5hbWUgdG8gYmUgdmVyaWZpZWQuXG4gKiBAcmV0dXJuIHs/QXJyYXkuPE1hdGNoPn0gVGhlIHJlc3VsdCBvZiBSZWdleHAuZXhlYyBvcGVyYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBfbnVsbF8gaWYgbm8gbWF0Y2hlcyBhcmUgZm91bmQuXG4gKi9cbm1ldGhvZHMuaXNWYWxpZENsYXNzID0gZnVuY3Rpb24gKGNsYXNzU3RyaW5nKSB7XG4gIC8vIHNvbWUucGFja2FnZS9zb21lLnBhY2thZ2UuQWN0aXZpdHlcbiAgcmV0dXJuIG5ldyBSZWdFeHAoL15bYS16QS1aMC05XFwuL19dKyQvKS5leGVjKGNsYXNzU3RyaW5nKTtcbn07XG5cbi8qKlxuICogRm9yY2UgYXBwbGljYXRpb24gdG8gc3RvcCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBwYWNrYWdlIG5hbWUgdG8gYmUgc3RvcHBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG91dHB1dCBvZiB0aGUgY29ycmVzcG9uZGluZyBhZGIgY29tbWFuZC5cbiAqL1xubWV0aG9kcy5mb3JjZVN0b3AgPSBhc3luYyBmdW5jdGlvbiAocGtnKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLnNoZWxsKFsnYW0nLCAnZm9yY2Utc3RvcCcsIHBrZ10pO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlciBkYXRhIG9mIHRoZSBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uIG9uIHRoZSBkZXZpY2VcbiAqIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBwYWNrYWdlIG5hbWUgdG8gYmUgY2xlYXJlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG91dHB1dCBvZiB0aGUgY29ycmVzcG9uZGluZyBhZGIgY29tbWFuZC5cbiAqL1xubWV0aG9kcy5jbGVhciA9IGFzeW5jIGZ1bmN0aW9uIChwa2cpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdjbGVhcicsIHBrZ10pO1xufTtcblxuLyoqXG4gKiBHcmFudCBhbGwgcGVybWlzc2lvbnMgcmVxdWVzdGVkIGJ5IHRoZSBwYXJ0aWN1bGFyIHBhY2thZ2UuXG4gKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWZ1bCBvbiBBbmRyb2lkIDYuMCsgYW5kIGZvciBhcHBsaWNhdGlvbnNcbiAqIHRoYXQgc3VwcG9ydCBjb21wb25lbnRzLWJhc2VkIHBlcm1pc3Npb25zIHNldHRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBwYWNrYWdlIG5hbWUgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IGFwayAtIFRoZSBwYXRoIHRvIHRoZSBhY3R1YWwgYXBrIGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd8Ym9vbGVhbn0gVGhlIG91dHB1dCBvZiB0aGUgY29ycmVzcG9uZGluZyBhZGIgY29tbWFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIF9mYWxzZV8gaWYgdGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyBjb21tYW5kIGV4ZWN1dGlvbi5cbiAqL1xubWV0aG9kcy5ncmFudEFsbFBlcm1pc3Npb25zID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgYXBrKSB7XG4gIGxldCBhcGlMZXZlbCA9IGF3YWl0IHRoaXMuZ2V0QXBpTGV2ZWwoKTtcbiAgbGV0IHRhcmdldFNkayA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKCFhcGspIHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgYXBrIG5vdCBwcm92aWRlZCwgY29uc2lkZXJpbmcgYXBrIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoZSBkZXZpY2VcbiAgICAgICAqIGFuZCBmZXRjaGluZyB0YXJnZXRTZGsgdXNpbmcgcGFja2FnZSBuYW1lLlxuICAgICAgICovXG4gICAgICB0YXJnZXRTZGsgPSBhd2FpdCB0aGlzLnRhcmdldFNka1ZlcnNpb25Vc2luZ1BLRyhwa2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRTZGsgPSBhd2FpdCB0aGlzLnRhcmdldFNka1ZlcnNpb25Gcm9tTWFuaWZlc3QoYXBrKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvL2F2b2lkaW5nIGxvZ2dpbmcgZXJyb3Igc3RhY2ssIGFzIGNhbGxpbmcgbGlicmFyeSBmdW5jdGlvbiB3b3VsZCBoYXZlIGxvZ2dlZFxuICAgIGxvZy53YXJuKGBSYW4gaW50byBwcm9ibGVtIGdldHRpbmcgdGFyZ2V0IFNESyB2ZXJzaW9uOyBpZ25vcmluZy4uLmApO1xuICB9XG4gIGlmIChhcGlMZXZlbCA+PSAyMyAmJiB0YXJnZXRTZGsgPj0gMjMpIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZGV2aWNlIGlzIHJ1bm5pbmcgQW5kcm9pZCA2LjAoQVBJIDIzKSBvciBoaWdoZXIsIGFuZCB5b3VyIGFwcCdzIHRhcmdldCBTREsgaXMgMjMgb3IgaGlnaGVyOlxuICAgICAqIFRoZSBhcHAgaGFzIHRvIGxpc3QgdGhlIHBlcm1pc3Npb25zIGluIHRoZSBtYW5pZmVzdC5cbiAgICAgKiByZWZlcjogaHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvcGVybWlzc2lvbnMvcmVxdWVzdGluZy5odG1sXG4gICAgICovXG4gICAgY29uc3Qgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ3BtJywgJ2R1bXAnLCBwa2ddKTtcbiAgICBjb25zdCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMuZ2V0UmVxUGVybWlzc2lvbnMocGtnLCBzdGRvdXQpO1xuICAgIGNvbnN0IGdyYW50ZWRQZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMuZ2V0R3JhbnRlZFBlcm1pc3Npb25zKHBrZywgc3Rkb3V0KTtcbiAgICBjb25zdCBwZXJtaXNzb25zVG9HcmFudCA9IHJlcXVlc3RlZFBlcm1pc3Npb25zLmZpbHRlcigoeCkgPT4gZ3JhbnRlZFBlcm1pc3Npb25zLmluZGV4T2YoeCkgPCAwKTtcbiAgICBpZiAoIXBlcm1pc3NvbnNUb0dyYW50Lmxlbmd0aCkge1xuICAgICAgbG9nLmluZm8oYCR7cGtnfSBjb250YWlucyBubyBwZXJtaXNzaW9ucyBhdmFpbGFibGUgZm9yIGdyYW50aW5nLmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEFzIGl0IGNvbnN1bWVzIG1vcmUgdGltZSBmb3IgZ3JhbnRpbmcgZWFjaCBwZXJtaXNzaW9uLFxuICAgIC8vIHRyeWluZyB0byBncmFudCBhbGwgcGVybWlzc2lvbiBieSBmb3JtaW5nIGVxdWl2YWxlbnQgY29tbWFuZC5cbiAgICAvLyBBbHNvLCBpdCBpcyBuZWNlc3NhcnkgdG8gc3BsaXQgbG9uZyBjb21tYW5kcyBpbnRvIGNodW5rcywgc2luY2UgdGhlIG1heGltdW0gbGVuZ3RoIG9mXG4gICAgLy8gYWRiIHNoZWxsIGJ1ZmZlciBpcyBsaW1pdGVkXG4gICAgbGV0IGNtZHMgPSBbXTtcbiAgICBsZXQgY21kQ2h1bmsgPSBbXTtcbiAgICBmb3IgKGxldCBwZXJtaXNzaW9uIG9mIHBlcm1pc3NvbnNUb0dyYW50KSB7XG4gICAgICBjb25zdCBuZXh0Q21kID0gWydwbScsICdncmFudCcsIHBrZywgcGVybWlzc2lvbiwgJzsnXTtcbiAgICAgIGlmIChuZXh0Q21kLmpvaW4oJyAnKS5sZW5ndGggKyBjbWRDaHVuay5qb2luKCcgJykubGVuZ3RoID49IE1BWF9TSEVMTF9CVUZGRVJfTEVOR1RIKSB7XG4gICAgICAgIGNtZHMucHVzaChjbWRDaHVuayk7XG4gICAgICAgIGNtZENodW5rID0gW107XG4gICAgICB9XG4gICAgICBjbWRDaHVuayA9IGNtZENodW5rLmNvbmNhdChuZXh0Q21kKTtcbiAgICB9XG4gICAgaWYgKGNtZENodW5rLmxlbmd0aCkge1xuICAgICAgY21kcy5wdXNoKGNtZENodW5rKTtcbiAgICB9XG4gICAgbG9nLmRlYnVnKGBHb3QgdGhlIGZvbGxvd2luZyBjb21tYW5kIGNodW5rcyB0byBleGVjdXRlOiAke2NtZHN9YCk7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgZm9yIChsZXQgY21kIG9mIGNtZHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc2hlbGwoY21kKSAmJiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdG8gZ2l2ZSB0aGUgbWV0aG9kIGEgY2hhbmNlIHRvIGFzc2lnbiBhbGwgdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBiZWZvcmUgdG8gcXVpdCBpbiBjYXNlIHdlJ2QgbGlrZSB0byBpZ25vcmUgdGhlIGVycm9yIG9uIHRoZSBoaWdoZXIgbGV2ZWxcbiAgICAgICAgbGFzdEVycm9yID0gZTtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLyoqXG4gKiBHcmFudCBzaW5nbGUgcGVybWlzc2lvbiBmb3IgdGhlIHBhcnRpY3VsYXIgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIHBhY2thZ2UgbmFtZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVybWlzc2lvbiAtIFRoZSBmdWxsIG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gYmUgZ3JhbnRlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hhbmdpbmcgcGVybWlzc2lvbnMuXG4gKi9cbm1ldGhvZHMuZ3JhbnRQZXJtaXNzaW9uID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgcGVybWlzc2lvbikge1xuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdncmFudCcsIHBrZywgcGVybWlzc2lvbl0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIm5vdCBhIGNoYW5nZWFibGUgcGVybWlzc2lvbiB0eXBlXCIpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV2b2tlIHNpbmdsZSBwZXJtaXNzaW9uIGZyb20gdGhlIHBhcnRpY3VsYXIgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIHBhY2thZ2UgbmFtZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVybWlzc2lvbiAtIFRoZSBmdWxsIG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gYmUgcmV2b2tlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hhbmdpbmcgcGVybWlzc2lvbnMuXG4gKi9cbm1ldGhvZHMucmV2b2tlUGVybWlzc2lvbiA9IGFzeW5jIGZ1bmN0aW9uIChwa2csIHBlcm1pc3Npb24pIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAncmV2b2tlJywgcGtnLCBwZXJtaXNzaW9uXSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwibm90IGEgY2hhbmdlYWJsZSBwZXJtaXNzaW9uIHR5cGVcIikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBncmFudGVkIHBlcm1pc3Npb25zIGZvciB0aGUgcGFydGljdWxhciBwYWNrYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgcGFja2FnZSBuYW1lIHRvIGJlIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbWRPdXRwdXQgW251bGxdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIGNvbnRhaW5pbmcgY29tbWFuZCBvdXRwdXQgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BtIGR1bXBfIGNvbW1hbmQuIEl0IHNwZWVkcyB0aGlzIG1ldGhvZCB1cFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwcmVzZW50LlxuICogQHJldHVybiB7YXJyYXl9IFRoZSBsaXN0IG9mIGdyYW50ZWQgcGVybWlzc2lvbnMgb3IgYW4gZW1wdHkgbGlzdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hhbmdpbmcgcGVybWlzc2lvbnMuXG4gKi9cbm1ldGhvZHMuZ2V0R3JhbnRlZFBlcm1pc3Npb25zID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgY21kT3V0cHV0ID0gbnVsbCkge1xuICBsZXQgc3Rkb3V0ID0gY21kT3V0cHV0IHx8IGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdkdW1wJywgcGtnXSk7XG4gIGxldCBtYXRjaCA9IG5ldyBSZWdFeHAoL2luc3RhbGwgcGVybWlzc2lvbnM6KFtcXHNcXFNdKj8pRFVNUCBPRiBTRVJWSUNFIGFjdGl2aXR5Oi9nKS5leGVjKHN0ZG91dCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgZ3JhbnRlZCBwZXJtaXNzaW9ucycpO1xuICB9XG4gIHJldHVybiAobWF0Y2hbMF0ubWF0Y2goL2FuZHJvaWRcXC5wZXJtaXNzaW9uXFwuXFx3KzpcXHNncmFudGVkPXRydWUvZykgfHwgW10pXG4gICAgLm1hcCgoeCkgPT4geC5yZXBsYWNlKC86XFxzZ3JhbnRlZD10cnVlL2csICcnKSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRlbmllZCBwZXJtaXNzaW9ucyBmb3IgdGhlIHBhcnRpY3VsYXIgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIHBhY2thZ2UgbmFtZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY21kT3V0cHV0IFtudWxsXSAtIE9wdGlvbmFsIHBhcmFtZXRlciBjb250YWluaW5nIGNvbW1hbmQgb3V0cHV0IG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wbSBkdW1wXyBjb21tYW5kLiBJdCBzcGVlZHMgdGhpcyBtZXRob2QgdXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcHJlc2VudC5cbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgbGlzdCBvZiBkZW5pZWQgcGVybWlzc2lvbnMgb3IgYW4gZW1wdHkgbGlzdC5cbiAqL1xubWV0aG9kcy5nZXREZW5pZWRQZXJtaXNzaW9ucyA9IGFzeW5jIGZ1bmN0aW9uIChwa2csIGNtZE91dHB1dCA9IG51bGwpIHtcbiAgbGV0IHN0ZG91dCA9IGNtZE91dHB1dCB8fCBhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAnZHVtcCcsIHBrZ10pO1xuICBsZXQgbWF0Y2ggPSBuZXcgUmVnRXhwKC9pbnN0YWxsIHBlcm1pc3Npb25zOihbXFxzXFxTXSo/KURVTVAgT0YgU0VSVklDRSBhY3Rpdml0eTovZykuZXhlYyhzdGRvdXQpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGRlbmllZCBwZXJtaXNzaW9ucycpO1xuICB9XG4gIHJldHVybiAobWF0Y2hbMF0ubWF0Y2goL2FuZHJvaWRcXC5wZXJtaXNzaW9uXFwuXFx3KzpcXHNncmFudGVkPWZhbHNlL2cpIHx8IFtdKVxuICAgIC5tYXAoKHgpID0+IHgucmVwbGFjZSgvOlxcc2dyYW50ZWQ9ZmFsc2UvZywgJycpKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgcmVxdWVzdGVkIHBlcm1pc3Npb25zIGZvciB0aGUgcGFydGljdWxhciBwYWNrYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgcGFja2FnZSBuYW1lIHRvIGJlIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbWRPdXRwdXQgW251bGxdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIGNvbnRhaW5pbmcgY29tbWFuZCBvdXRwdXQgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BtIGR1bXBfIGNvbW1hbmQuIEl0IHNwZWVkcyB0aGlzIG1ldGhvZCB1cFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwcmVzZW50LlxuICogQHJldHVybiB7YXJyYXl9IFRoZSBsaXN0IG9mIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyBvciBhbiBlbXB0eSBsaXN0LlxuICovXG5tZXRob2RzLmdldFJlcVBlcm1pc3Npb25zID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgY21kT3V0cHV0ID0gbnVsbCkge1xuICBsZXQgc3Rkb3V0ID0gY21kT3V0cHV0IHx8IGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdkdW1wJywgcGtnXSk7XG4gIGxldCBtYXRjaCA9IG5ldyBSZWdFeHAoL3JlcXVlc3RlZCBwZXJtaXNzaW9uczooW1xcc1xcU10qPylpbnN0YWxsIHBlcm1pc3Npb25zOi9nKS5leGVjKHN0ZG91dCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgcmVxdWVzdGVkIHBlcm1pc3Npb25zJyk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoWzBdLm1hdGNoKC9hbmRyb2lkXFwucGVybWlzc2lvblxcLlxcdysvZykgfHwgW107XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGxvY2F0aW9uIHByb3ZpZGVycyBmb3IgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgbG9jYXRpb24gcHJvdmlkZXJzIG9yIGFuIGVtcHR5IGxpc3QuXG4gKi9cbm1ldGhvZHMuZ2V0TG9jYXRpb25Qcm92aWRlcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLmdldFNldHRpbmcoJ3NlY3VyZScsICdsb2NhdGlvbl9wcm92aWRlcnNfYWxsb3dlZCcpO1xuICByZXR1cm4gc3Rkb3V0LnRyaW0oKS5zcGxpdCgnLCcpXG4gICAgLm1hcCgocCkgPT4gcC50cmltKCkpXG4gICAgLmZpbHRlcihCb29sZWFuKTtcbn07XG5cbi8qKlxuICogVG9nZ2xlIHRoZSBzdGF0ZSBvZiBHUFMgbG9jYXRpb24gcHJvdmlkZXIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIC0gV2hldGhlciB0byBlbmFibGUgKHRydWUpIG9yIGRpc2FibGUgKGZhbHNlKSB0aGUgR1BTIHByb3ZpZGVyLlxuICovXG5tZXRob2RzLnRvZ2dsZUdQU0xvY2F0aW9uUHJvdmlkZXIgPSBhc3luYyBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICBhd2FpdCB0aGlzLnNldFNldHRpbmcoJ3NlY3VyZScsICdsb2NhdGlvbl9wcm92aWRlcnNfYWxsb3dlZCcsIGAke2VuYWJsZWQgPyBcIitcIiA6IFwiLVwifWdwc2ApO1xufTtcblxuLyoqXG4gKiBTdG9wIHRoZSBwYXJ0aWN1bGFyIHBhY2thZ2UgaWYgaXQgaXMgcnVubmluZyBhbmQgY2xlYXJzIGl0cyBhcHBsaWNhdGlvbiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgcGFja2FnZSBuYW1lIHRvIGJlIHByb2Nlc3NlZC5cbiAqL1xubWV0aG9kcy5zdG9wQW5kQ2xlYXIgPSBhc3luYyBmdW5jdGlvbiAocGtnKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5mb3JjZVN0b3AocGtnKTtcbiAgICBhd2FpdCB0aGlzLmNsZWFyKHBrZyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ2Fubm90IHN0b3AgYW5kIGNsZWFyICR7cGtnfS4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB0YXJnZXQgU0RLIHZlcnNpb24gZm9yIHRoZSBwYXJ0aWN1bGFyIHBhY2thZ2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBwYWNrYWdlIG5hbWUgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGFyc2VkIFNESyB2ZXJzaW9uLlxuICovXG5tZXRob2RzLmdldFRhcmdldFNka1VzaW5nUEtHID0gYXN5bmMgZnVuY3Rpb24gKHBrZykge1xuICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ3BtJywgJ2R1bXAnLCBwa2ddKTtcbiAgbGV0IHRhcmdldFNkayA9IG5ldyBSZWdFeHAoL3RhcmdldFNkaz0oW15cXHNcXHNdKykvZykuZXhlYyhzdGRvdXQpWzFdO1xuICByZXR1cm4gdGFyZ2V0U2RrO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgaW5wdXQgbWV0aG9kcyAoSU1FcykgZm9yIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48U3RyaW5nPn0gVGhlIGxpc3Qgb2YgSU1FIG5hbWVzIG9yIGFuIGVtcHR5IGxpc3QuXG4gKi9cbm1ldGhvZHMuYXZhaWxhYmxlSU1FcyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0SU1FTGlzdEZyb21PdXRwdXQoYXdhaXQgdGhpcy5zaGVsbChbJ2ltZScsICdsaXN0JywgJy1hJ10pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBnZXR0aW5nIGF2YWlsYWJsZSBJTUUncy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGVuYWJsZWQgaW5wdXQgbWV0aG9kcyAoSU1FcykgZm9yIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48U3RyaW5nPn0gVGhlIGxpc3Qgb2YgZW5hYmxlZCBJTUUgbmFtZXMgb3IgYW4gZW1wdHkgbGlzdC5cbiAqL1xubWV0aG9kcy5lbmFibGVkSU1FcyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0SU1FTGlzdEZyb21PdXRwdXQoYXdhaXQgdGhpcy5zaGVsbChbJ2ltZScsICdsaXN0J10pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBnZXR0aW5nIGVuYWJsZWQgSU1FJ3MuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgdGhlIHBhcnRpY3VsYXIgaW5wdXQgbWV0aG9kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1lSWQgLSBPbmUgb2YgZXhpc3RpbmcgSU1FIGlkcy5cbiAqL1xubWV0aG9kcy5lbmFibGVJTUUgPSBhc3luYyBmdW5jdGlvbiAoaW1lSWQpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2ltZScsICdlbmFibGUnLCBpbWVJZF0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSBwYXJ0aWN1bGFyIGlucHV0IG1ldGhvZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGltZUlkIC0gT25lIG9mIGV4aXN0aW5nIElNRSBpZHMuXG4gKi9cbm1ldGhvZHMuZGlzYWJsZUlNRSA9IGFzeW5jIGZ1bmN0aW9uIChpbWVJZCkge1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnaW1lJywgJ2Rpc2FibGUnLCBpbWVJZF0pO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhcnRpY3VsYXIgaW5wdXQgbWV0aG9kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1lSWQgLSBPbmUgb2YgZXhpc3RpbmcgSU1FIGlkcy5cbiAqL1xubWV0aG9kcy5zZXRJTUUgPSBhc3luYyBmdW5jdGlvbiAoaW1lSWQpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2ltZScsICdzZXQnLCBpbWVJZF0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgaW5wdXQgbWV0aG9kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGlucHV0IG1ldGhvZC5cbiAqL1xubWV0aG9kcy5kZWZhdWx0SU1FID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGxldCBlbmdpbmUgPSBhd2FpdCB0aGlzLmdldFNldHRpbmcoJ3NlY3VyZScsICdkZWZhdWx0X2lucHV0X21ldGhvZCcpO1xuICAgIHJldHVybiBlbmdpbmUudHJpbSgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEVycm9yIGdldHRpbmcgZGVmYXVsdCBJTUUuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kIHRoZSBwYXJ0aWN1bGFyIGtleWNvZGUgdG8gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0ga2V5Y29kZSAtIFRoZSBhY3R1YWwga2V5IGNvZGUgdG8gYmUgc2VudC5cbiAqL1xubWV0aG9kcy5rZXlldmVudCA9IGFzeW5jIGZ1bmN0aW9uIChrZXljb2RlKSB7XG4gIC8vIGtleWNvZGUgbXVzdCBiZSBhbiBpbnQuXG4gIGxldCBjb2RlID0gcGFyc2VJbnQoa2V5Y29kZSwgMTApO1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnaW5wdXQnLCAna2V5ZXZlbnQnLCBjb2RlXSk7XG59O1xuXG4vKipcbiAqIFNlbmQgdGhlIHBhcnRpY3VsYXIgdGV4dCB0byB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgYWN0dWFsIHRleHQgdG8gYmUgc2VudC5cbiAqL1xubWV0aG9kcy5pbnB1dFRleHQgPSBhc3luYyBmdW5jdGlvbiAodGV4dCkge1xuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIC8vIG5lZWQgdG8gZXNjYXBlIHdoaXRlc3BhY2UgYW5kICggKSA8ID4gfCA7ICYgKiBcXCB+IFwiICdcbiAgdGV4dCA9IHRleHRcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXCgvZywgJ1xcKCcpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcKS9nLCAnXFwpJylcbiAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnXFw8JylcbiAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnXFw+JylcbiAgICAgICAgICAucmVwbGFjZSgvXFx8L2csICdcXHwnKVxuICAgICAgICAgIC5yZXBsYWNlKC87L2csICdcXDsnKVxuICAgICAgICAgIC5yZXBsYWNlKC8mL2csICdcXCYnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXCovZywgJ1xcKicpXG4gICAgICAgICAgLnJlcGxhY2UoL34vZywgJ1xcficpXG4gICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFwiJylcbiAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcJ1wiKVxuICAgICAgICAgIC5yZXBsYWNlKC8gL2csICclcycpO1xuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnaW5wdXQnLCAndGV4dCcsIHRleHRdKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGFjdGl2ZSB0ZXh0IGZpZWxkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdCBieSBzZW5kaW5nXG4gKiBzcGVjaWFsIGtleWV2ZW50cyB0byBpdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFsxMDBdIC0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSB0ZXh0IGluIHRoZSBmaWVsZCB0byBiZSBjbGVhcmVkLlxuICovXG5tZXRob2RzLmNsZWFyVGV4dEZpZWxkID0gYXN5bmMgZnVuY3Rpb24gKGxlbmd0aCA9IDEwMCkge1xuICAvLyBhc3N1bWVzIHRoYXQgdGhlIEVkaXRUZXh0IGZpZWxkIGFscmVhZHkgaGFzIGZvY3VzXG4gIGxvZy5kZWJ1ZyhgQ2xlYXJpbmcgdXAgdG8gJHtsZW5ndGh9IGNoYXJhY3RlcnNgKTtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYXJncyA9IFsnaW5wdXQnLCAna2V5ZXZlbnQnXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIC8vIHdlIGNhbm5vdCBrbm93IHdoZXJlIHRoZSBjdXJzb3IgaXMgaW4gdGhlIHRleHQgZmllbGQsIHNvIGRlbGV0ZSBib3RoIGJlZm9yZVxuICAgIC8vIGFuZCBhZnRlciBzbyB0aGF0IHdlIGdldCByaWQgb2YgZXZlcnl0aGluZ1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL3ZpZXcvS2V5RXZlbnQuaHRtbCNLRVlDT0RFX0RFTFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL3ZpZXcvS2V5RXZlbnQuaHRtbCNLRVlDT0RFX0ZPUldBUkRfREVMXG4gICAgYXJncy5wdXNoKCc2NycsICcxMTInKTtcbiAgfVxuICBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xufTtcblxuLyoqXG4gKiBTZW5kIHRoZSBzcGVjaWFsIGtleWNvZGUgdG8gdGhlIGRldmljZSB1bmRlciB0ZXN0IGluIG9yZGVyIHRvIGxvY2sgaXQuXG4gKi9cbm1ldGhvZHMubG9jayA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGxvY2tlZCA9IGF3YWl0IHRoaXMuaXNTY3JlZW5Mb2NrZWQoKTtcbiAgaWYgKCFsb2NrZWQpIHtcbiAgICBsb2cuZGVidWcoXCJQcmVzc2luZyB0aGUgS0VZQ09ERV9QT1dFUiBidXR0b24gdG8gbG9jayBzY3JlZW5cIik7XG4gICAgYXdhaXQgdGhpcy5rZXlldmVudCgyNik7XG5cbiAgICAvLyB3YWl0IGZvciB0aGUgc2NyZWVuIHRvIGxvY2tcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDEwLCA1MDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGxvY2tlZCA9IGF3YWl0IHRoaXMuaXNTY3JlZW5Mb2NrZWQoKTtcbiAgICAgIGlmICghbG9ja2VkKSB7XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KFwiV2FpdGluZyBmb3Igc2NyZWVuIHRvIGxvY2suXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGxvZy5kZWJ1ZyhcIlNjcmVlbiBpcyBhbHJlYWR5IGxvY2tlZC4gRG9pbmcgbm90aGluZy5cIik7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZCB0aGUgc3BlY2lhbCBrZXljb2RlIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdCBpbiBvcmRlciB0byBlbXVsYXRlXG4gKiBCYWNrIGJ1dHRvbiB0YXAuXG4gKi9cbm1ldGhvZHMuYmFjayA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiUHJlc3NpbmcgdGhlIEJBQ0sgYnV0dG9uXCIpO1xuICBhd2FpdCB0aGlzLmtleWV2ZW50KDQpO1xufTtcblxuLyoqXG4gKiBTZW5kIHRoZSBzcGVjaWFsIGtleWNvZGUgdG8gdGhlIGRldmljZSB1bmRlciB0ZXN0IGluIG9yZGVyIHRvIGVtdWxhdGVcbiAqIEhvbWUgYnV0dG9uIHRhcC5cbiAqL1xubWV0aG9kcy5nb1RvSG9tZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiUHJlc3NpbmcgdGhlIEhPTUUgYnV0dG9uXCIpO1xuICBhd2FpdCB0aGlzLmtleWV2ZW50KDMpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBhY3R1YWwgcGF0aCB0byBhZGIgZXhlY3V0YWJsZS5cbiAqL1xubWV0aG9kcy5nZXRBZGJQYXRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5leGVjdXRhYmxlLnBhdGg7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIG9mIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGVuY29kZWQgYXMgYW4gaW50ZWdlciBudW1iZXIuXG4gKi9cbm1ldGhvZHMuZ2V0U2NyZWVuT3JpZW50YXRpb24gPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZHVtcHN5cycsICdpbnB1dCddKTtcbiAgcmV0dXJuIGdldFN1cmZhY2VPcmllbnRhdGlvbihzdGRvdXQpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgc2NyZWVuIGxvY2sgc3RhdGUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGRldmljZSBpcyBsb2NrZWQuXG4gKi9cbm1ldGhvZHMuaXNTY3JlZW5Mb2NrZWQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZHVtcHN5cycsICd3aW5kb3cnXSk7XG4gIGlmIChwcm9jZXNzLmVudi5BUFBJVU1fTE9HX0RVTVBTWVMpIHtcbiAgICAvLyBvcHRpb25hbCBkZWJ1Z2dpbmdcbiAgICAvLyBpZiB0aGUgbWV0aG9kIGlzIG5vdCB3b3JraW5nLCB0dXJuIGl0IG9uIGFuZCBzZW5kIHVzIHRoZSBvdXRwdXRcbiAgICBsZXQgZHVtcHN5c0ZpbGUgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgXCJkdW1wc3lzLmxvZ1wiKTtcbiAgICBsb2cuZGVidWcoYFdyaXRpbmcgZHVtcHN5cyBvdXRwdXQgdG8gJHtkdW1wc3lzRmlsZX1gKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHVtcHN5c0ZpbGUsIHN0ZG91dCk7XG4gIH1cbiAgcmV0dXJuIChpc1Nob3dpbmdMb2Nrc2NyZWVuKHN0ZG91dCkgfHwgaXNDdXJyZW50Rm9jdXNPbktleWd1YXJkKHN0ZG91dCkgfHxcbiAgICAgICAgICAhaXNTY3JlZW5PbkZ1bGx5KHN0ZG91dCkpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgc3RhdGUgb2YgdGhlIHNvZnR3YXJlIGtleWJvYXJkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzb2Z0d2FyZSBrZXlib2FyZCBpcyBwcmVzZW50LlxuICovXG5tZXRob2RzLmlzU29mdEtleWJvYXJkUHJlc2VudCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ2R1bXBzeXMnLCAnaW5wdXRfbWV0aG9kJ10pO1xuICAgIGxldCBpc0tleWJvYXJkU2hvd24gPSBmYWxzZSxcbiAgICAgICAgY2FuQ2xvc2VLZXlib2FyZCA9IGZhbHNlLFxuICAgICAgICBpbnB1dFNob3duTWF0Y2ggPSAvbUlucHV0U2hvd249XFx3Ky9naS5leGVjKHN0ZG91dCk7XG4gICAgaWYgKGlucHV0U2hvd25NYXRjaCAmJiBpbnB1dFNob3duTWF0Y2hbMF0pIHtcbiAgICAgIGlzS2V5Ym9hcmRTaG93biA9IGlucHV0U2hvd25NYXRjaFswXS5zcGxpdCgnPScpWzFdID09PSAndHJ1ZSc7XG4gICAgICBsZXQgaXNJbnB1dFZpZXdTaG93bk1hdGNoID0gL21Jc0lucHV0Vmlld1Nob3duPVxcdysvZ2kuZXhlYyhzdGRvdXQpO1xuICAgICAgaWYgKGlzSW5wdXRWaWV3U2hvd25NYXRjaCAmJiBpc0lucHV0Vmlld1Nob3duTWF0Y2hbMF0pIHtcbiAgICAgICAgY2FuQ2xvc2VLZXlib2FyZCA9IGlzSW5wdXRWaWV3U2hvd25NYXRjaFswXS5zcGxpdCgnPScpWzFdID09PSAndHJ1ZSc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7aXNLZXlib2FyZFNob3duLCBjYW5DbG9zZUtleWJvYXJkfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBmaW5kaW5nIHNvZnRrZXlib2FyZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmQgYW4gYXJiaXRyYXJ5IFRlbG5ldCBjb21tYW5kIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFRoZSBjb21tYW5kIHRvIGJlIHNlbnQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgYWN0dWFsIG91dHB1dCBvZiB0aGUgZ2l2ZW4gY29tbWFuZC5cbiAqL1xubWV0aG9kcy5zZW5kVGVsbmV0Q29tbWFuZCA9IGFzeW5jIGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gIGxvZy5kZWJ1ZyhgU2VuZGluZyB0ZWxuZXQgY29tbWFuZCB0byBkZXZpY2U6ICR7Y29tbWFuZH1gKTtcbiAgbGV0IHBvcnQgPSBhd2FpdCB0aGlzLmdldEVtdWxhdG9yUG9ydCgpO1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBjb25uID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24ocG9ydCwgJ2xvY2FsaG9zdCcpLFxuICAgICAgICBjb25uZWN0ZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZHlSZWdleCA9IC9eT0skL20sXG4gICAgICAgIGRhdGFTdHJlYW0gPSBcIlwiLFxuICAgICAgICByZXMgPSBudWxsO1xuICAgIGNvbm4ub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBsb2cuZGVidWcoXCJTb2NrZXQgY29ubmVjdGlvbiB0byBkZXZpY2UgY3JlYXRlZFwiKTtcbiAgICB9KTtcbiAgICBjb25uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgICBpZiAocmVhZHlSZWdleC50ZXN0KGRhdGEpKSB7XG4gICAgICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBsb2cuZGVidWcoXCJTb2NrZXQgY29ubmVjdGlvbiB0byBkZXZpY2UgcmVhZHlcIik7XG4gICAgICAgICAgY29ubi53cml0ZShgJHtjb21tYW5kfVxcbmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhU3RyZWFtICs9IGRhdGE7XG4gICAgICAgIGlmIChyZWFkeVJlZ2V4LnRlc3QoZGF0YSkpIHtcbiAgICAgICAgICByZXMgPSBkYXRhU3RyZWFtLnJlcGxhY2UocmVhZHlSZWdleCwgXCJcIikudHJpbSgpO1xuICAgICAgICAgIHJlcyA9IF8ubGFzdChyZXMudHJpbSgpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgbG9nLmRlYnVnKGBUZWxuZXQgY29tbWFuZCBnb3QgcmVzcG9uc2U6ICR7cmVzfWApO1xuICAgICAgICAgIGNvbm4ud3JpdGUoXCJxdWl0XFxuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29ubi5vbignZXJyb3InLCAoZXJyKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gICAgICBsb2cuZGVidWcoYFRlbG5ldCBjb21tYW5kIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSk7XG4gICAgY29ubi5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJOZXZlciBnb3QgYSByZXNwb25zZSBmcm9tIGNvbW1hbmRcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHN0YXRlIG9mIEFpcnBsYW5lIG1vZGUgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgQWlycGxhbmUgbW9kZSBpcyBlbmFibGVkLlxuICovXG5tZXRob2RzLmlzQWlycGxhbmVNb2RlT24gPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLmdldFNldHRpbmcoJ2dsb2JhbCcsICdhaXJwbGFuZV9tb2RlX29uJyk7XG4gIHJldHVybiBwYXJzZUludChzdGRvdXQsIDEwKSAhPT0gMDtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBzdGF0ZSBvZiBBaXJwbGFuZSBtb2RlIGluIFNldHRpbmdzIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9uIC0gVHJ1ZSB0byBlbmFibGUgdGhlIEFpcnBsYW5lIG1vZGUgaW4gU2V0dGluZ3MgYW5kIGZhbHNlIHRvIGRpc2FibGUgaXQuXG4gKi9cbm1ldGhvZHMuc2V0QWlycGxhbmVNb2RlID0gYXN5bmMgZnVuY3Rpb24gKG9uKSB7XG4gIGF3YWl0IHRoaXMuc2V0U2V0dGluZygnZ2xvYmFsJywgJ2FpcnBsYW5lX21vZGVfb24nLCBvbiA/IDEgOiAwKTtcbn07XG5cbi8qKlxuICogQnJvYWRjYXN0IHRoZSBzdGF0ZSBvZiBBaXJwbGFuZSBtb2RlIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIge0BsaW5rICNzZXRBaXJwbGFuZU1vZGV9LCBvdGhlcndpc2VcbiAqIHRoZSBtb2RlIGNoYW5nZSBpcyBub3QgZ29pbmcgdG8gYmUgYXBwbGllZCBmb3IgdGhlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9uIC0gVHJ1ZSB0byBicm9hZGNhc3QgZW5hYmxlIGFuZCBmYWxzZSB0byBicm9hZGNhc3QgZGlzYWJsZS5cbiAqL1xubWV0aG9kcy5icm9hZGNhc3RBaXJwbGFuZU1vZGUgPSBhc3luYyBmdW5jdGlvbiAob24pIHtcbiAgbGV0IGFyZ3MgPSBbJ2FtJywgJ2Jyb2FkY2FzdCcsICctYScsICdhbmRyb2lkLmludGVudC5hY3Rpb24uQUlSUExBTkVfTU9ERScsXG4gICAgICAgICAgICAgICctLWV6JywgJ3N0YXRlJywgb24gPyAndHJ1ZScgOiAnZmFsc2UnXTtcbiAgYXdhaXQgdGhpcy5zaGVsbChhcmdzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHN0YXRlIG9mIFdpRmkgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgV2lGaSBpcyBlbmFibGVkLlxuICovXG5tZXRob2RzLmlzV2lmaU9uID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5nZXRTZXR0aW5nKCdnbG9iYWwnLCAnd2lmaV9vbicpO1xuICByZXR1cm4gKHBhcnNlSW50KHN0ZG91dCwgMTApICE9PSAwKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBzdGF0ZSBvZiBXaUZpIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9uIC0gVHJ1ZSB0byBlbmFibGUgYW5kIGZhbHNlIHRvIGRpc2FibGUgaXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW11bGF0b3IgW2ZhbHNlXSAtIFNldCBpdCB0byB0cnVlIGlmIHRoZSBkZXZpY2UgdW5kZXIgdGVzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBhbiBlbXVsYXRvciByYXRoZXIgdGhhbiBhIHJlYWwgZGV2aWNlLlxuICovXG5tZXRob2RzLnNldFdpZmlTdGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIChvbiwgaXNFbXVsYXRvciA9IGZhbHNlKSB7XG4gIGlmIChpc0VtdWxhdG9yKSB7XG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N2YycsICd3aWZpJywgb24gPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdicm9hZGNhc3QnLCAnLWEnLCBXSUZJX0NPTk5FQ1RJT05fU0VUVElOR19BQ1RJT04sXG4gICAgICAgICAgICAgICAgICAgICAgJy1uJywgV0lGSV9DT05ORUNUSU9OX1NFVFRJTkdfUkVDRUlWRVIsXG4gICAgICAgICAgICAgICAgICAgICAgJy0tZXMnLCAnc2V0c3RhdHVzJywgb24gPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10pO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBzdGF0ZSBvZiBEYXRhIHRyYW5zZmVyIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIERhdGEgdHJhbnNmZXIgaXMgZW5hYmxlZC5cbiAqL1xubWV0aG9kcy5pc0RhdGFPbiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuZ2V0U2V0dGluZygnZ2xvYmFsJywgJ21vYmlsZV9kYXRhJyk7XG4gIHJldHVybiAocGFyc2VJbnQoc3Rkb3V0LCAxMCkgIT09IDApO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHN0YXRlIG9mIERhdGEgdHJhbnNmZXIgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb24gLSBUcnVlIHRvIGVuYWJsZSBhbmQgZmFsc2UgdG8gZGlzYWJsZSBpdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbXVsYXRvciBbZmFsc2VdIC0gU2V0IGl0IHRvIHRydWUgaWYgdGhlIGRldmljZSB1bmRlciB0ZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGFuIGVtdWxhdG9yIHJhdGhlciB0aGFuIGEgcmVhbCBkZXZpY2UuXG4gKi9cbm1ldGhvZHMuc2V0RGF0YVN0YXRlID0gYXN5bmMgZnVuY3Rpb24gKG9uLCBpc0VtdWxhdG9yID0gZmFsc2UpIHtcbiAgaWYgKGlzRW11bGF0b3IpIHtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc3ZjJywgJ2RhdGEnLCBvbiA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ2FtJywgJ2Jyb2FkY2FzdCcsICctYScsIERBVEFfQ09OTkVDVElPTl9TRVRUSU5HX0FDVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAnLW4nLCBEQVRBX0NPTk5FQ1RJT05fU0VUVElOR19SRUNFSVZFUixcbiAgICAgICAgICAgICAgICAgICAgICAnLS1lcycsICdzZXRzdGF0dXMnLCBvbiA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBzdGF0ZSBvZiBXaUZpIGFuZC9vciBEYXRhIHRyYW5zZmVyIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHdpZmkgLSBUcnVlIHRvIGVuYWJsZSBhbmQgZmFsc2UgdG8gZGlzYWJsZSBXaUZpLlxuICogQHBhcmFtIHtib29sZWFufSBkYXRhIC0gVHJ1ZSB0byBlbmFibGUgYW5kIGZhbHNlIHRvIGRpc2FibGUgRGF0YSB0cmFuc2Zlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbXVsYXRvciBbZmFsc2VdIC0gU2V0IGl0IHRvIHRydWUgaWYgdGhlIGRldmljZSB1bmRlciB0ZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGFuIGVtdWxhdG9yIHJhdGhlciB0aGFuIGEgcmVhbCBkZXZpY2UuXG4gKi9cbm1ldGhvZHMuc2V0V2lmaUFuZERhdGEgPSBhc3luYyBmdW5jdGlvbiAoe3dpZmksIGRhdGF9LCBpc0VtdWxhdG9yID0gZmFsc2UpIHtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHdpZmkpKSB7XG4gICAgdGhpcy5zZXRXaWZpU3RhdGUod2lmaSwgaXNFbXVsYXRvcik7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgdGhpcy5zZXREYXRhU3RhdGUoZGF0YSwgaXNFbXVsYXRvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBzdGF0ZSBvZiBhbmltYXRpb24gb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogQW5pbWF0aW9uIG9uIHRoZSBkZXZpY2UgaXMgY29udHJvbGxlZCBieSB0aGUgZm9sbG93aW5nIGdsb2JhbCBwcm9wZXJ0aWVzOlxuICogW0FOSU1BVE9SX0RVUkFUSU9OX1NDQUxFXXtAbGluayBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvYW5kcm9pZC9wcm92aWRlci9TZXR0aW5ncy5HbG9iYWwuaHRtbCNBTklNQVRPUl9EVVJBVElPTl9TQ0FMRX0sXG4gKiBbVFJBTlNJVElPTl9BTklNQVRJT05fU0NBTEVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL3Byb3ZpZGVyL1NldHRpbmdzLkdsb2JhbC5odG1sI1RSQU5TSVRJT05fQU5JTUFUSU9OX1NDQUxFfSxcbiAqIFtXSU5ET1dfQU5JTUFUSU9OX1NDQUxFXXtAbGluayBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvYW5kcm9pZC9wcm92aWRlci9TZXR0aW5ncy5HbG9iYWwuaHRtbCNXSU5ET1dfQU5JTUFUSU9OX1NDQUxFfS5cbiAqIFRoaXMgbWV0aG9kIHNldHMgYWxsIHRoaXMgcHJvcGVydGllcyB0byAwLjAgdG8gZGlzYWJsZSAoMS4wIHRvIGVuYWJsZSkgYW5pbWF0aW9uLlxuICpcbiAqIFR1cm5pbmcgb2ZmIGFuaW1hdGlvbiBtaWdodCBiZSB1c2VmdWwgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAqIGFuZCByZWR1Y2UgdGVzdHMgZXhlY3V0aW9uIHRpbWUuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBvbiAtIFRydWUgdG8gZW5hYmxlIGFuZCBmYWxzZSB0byBkaXNhYmxlIGl0LlxuICovXG5tZXRob2RzLnNldEFuaW1hdGlvblN0YXRlID0gYXN5bmMgZnVuY3Rpb24gKG9uKSB7XG4gIGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdicm9hZGNhc3QnLCAnLWEnLCBBTklNQVRJT05fU0VUVElOR19BQ1RJT04sXG4gICAgICAgICAgICAgICAgICAgICctbicsIEFOSU1BVElPTl9TRVRUSU5HX1JFQ0VJVkVSLFxuICAgICAgICAgICAgICAgICAgICAnLS1lcycsICdzZXRzdGF0dXMnLCBvbiA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBzdGF0ZSBvZiBhbmltYXRpb24gb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYXQgbGVhc3Qgb25lIG9mIGFuaW1hdGlvbiBzY2FsZSBzZXR0aW5nc1xuICogICAgICAgICAgICAgICAgICAgaXMgbm90IGVxdWFsIHRvICcwLjAnLlxuICovXG5tZXRob2RzLmlzQW5pbWF0aW9uT24gPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBhbmltYXRvcl9kdXJhdGlvbl9zY2FsZSA9IGF3YWl0IHRoaXMuZ2V0U2V0dGluZygnZ2xvYmFsJywgJ2FuaW1hdG9yX2R1cmF0aW9uX3NjYWxlJyk7XG4gIGxldCB0cmFuc2l0aW9uX2FuaW1hdGlvbl9zY2FsZSA9IGF3YWl0IHRoaXMuZ2V0U2V0dGluZygnZ2xvYmFsJywgJ3RyYW5zaXRpb25fYW5pbWF0aW9uX3NjYWxlJyk7XG4gIGxldCB3aW5kb3dfYW5pbWF0aW9uX3NjYWxlID0gYXdhaXQgdGhpcy5nZXRTZXR0aW5nKCdnbG9iYWwnLCAnd2luZG93X2FuaW1hdGlvbl9zY2FsZScpO1xuICByZXR1cm4gXy5zb21lKFthbmltYXRvcl9kdXJhdGlvbl9zY2FsZSwgdHJhbnNpdGlvbl9hbmltYXRpb25fc2NhbGUsIHdpbmRvd19hbmltYXRpb25fc2NhbGVdLFxuICAgICAgICAgICAgICAgIChzZXR0aW5nKSA9PiBzZXR0aW5nICE9PSAnMC4wJyk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExvY2F0aW9uXG4gKiBAcHJvcGVydHkge2Zsb2F0fHN0cmluZ30gbG9uZ2l0dWRlIC0gVmFsaWQgbG9uZ2l0dWRlIHZhbHVlLlxuICogQHByb3BlcnR5IHtmbG9hdHxzdHJpbmd9IGxhdGl0dWRlIC0gVmFsaWQgbGF0aXR1ZGUgdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBFbXVsYXRlIGdlb2xvY2F0aW9uIGNvb3JkaW5hdGVzIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge0xvY2F0aW9ufSBsb2NhdGlvbiAtIExvY2F0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbXVsYXRvciBbZmFsc2VdIC0gU2V0IGl0IHRvIHRydWUgaWYgdGhlIGRldmljZSB1bmRlciB0ZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGFuIGVtdWxhdG9yIHJhdGhlciB0aGFuIGEgcmVhbCBkZXZpY2UuXG4gKi9cbm1ldGhvZHMuc2V0R2VvTG9jYXRpb24gPSBhc3luYyBmdW5jdGlvbiAobG9jYXRpb24sIGlzRW11bGF0b3IgPSBmYWxzZSkge1xuICBsZXQgbG9uZ2l0dWRlID0gcGFyc2VGbG9hdChsb2NhdGlvbi5sb25naXR1ZGUpO1xuICBpZiAoaXNOYU4obG9uZ2l0dWRlKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBsb2NhdGlvbi5sb25naXR1ZGUgaXMgZXhwZWN0ZWQgdG8gYmUgYSB2YWxpZCBmbG9hdCBudW1iZXIuICcke2xvY2F0aW9uLmxvbmdpdHVkZX0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBsb25naXR1ZGUgPSBgJHtfLmNlaWwobG9uZ2l0dWRlLCA1KX1gO1xuICBsZXQgbGF0aXR1ZGUgPSBwYXJzZUZsb2F0KGxvY2F0aW9uLmxhdGl0dWRlKTtcbiAgaWYgKGlzTmFOKGxhdGl0dWRlKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBsb2NhdGlvbi5sYXRpdHVkZSBpcyBleHBlY3RlZCB0byBiZSBhIHZhbGlkIGZsb2F0IG51bWJlci4gJyR7bG9jYXRpb24ubGF0aXR1ZGV9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgbGF0aXR1ZGUgPSBgJHtfLmNlaWwobGF0aXR1ZGUsIDUpfWA7XG4gIGlmIChpc0VtdWxhdG9yKSB7XG4gICAgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICAgIHRoaXMuYWRiRXhlYyhbJ2VtdScsICdnZW8nLCAnZml4JywgbG9uZ2l0dWRlLCBsYXRpdHVkZV0pO1xuICAgIC8vIEEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MjA2MTgwXG4gICAgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2dlbycsICdmaXgnLCBsb25naXR1ZGUucmVwbGFjZSgnLicsICcsJyksIGxhdGl0dWRlLnJlcGxhY2UoJy4nLCAnLCcpXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdzdGFydHNlcnZpY2UnLCAnLWUnLCAnbG9uZ2l0dWRlJywgbG9uZ2l0dWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLWUnLCAnbGF0aXR1ZGUnLCBsYXRpdHVkZSwgTE9DQVRJT05fU0VSVklDRV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlZnVsbHkgcmVjdXJzaXZlbHkgcmVtb3ZlIGEgcGF0aCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiBCZSBjYXJlZnVsIHdoaWxlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byBiZSByZW1vdmVkIHJlY3Vyc2l2ZWx5LlxuICovXG5tZXRob2RzLnJpbXJhZiA9IGFzeW5jIGZ1bmN0aW9uIChwYXRoKSB7XG4gIGF3YWl0IHRoaXMuc2hlbGwoWydybScsICctcmYnLCBwYXRoXSk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBmaWxlIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoIC0gVGhlIHBhdGggdG8gdGhlIGZpbGUgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgZGVzdGluYXRpb24gcGF0aCBvbiB0aGUgcmVtb3RlIGRldmljZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzLFxuICogICAgICAgICAgICAgICAgICAgICAgICBfZXhlY18gbWV0aG9kIG9wdGlvbnMsIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGF2YWlsYWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICovXG5tZXRob2RzLnB1c2ggPSBhc3luYyBmdW5jdGlvbiAobG9jYWxQYXRoLCByZW1vdGVQYXRoLCBvcHRzKSB7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3B1c2gnLCBsb2NhbFBhdGgsIHJlbW90ZVBhdGhdLCBvcHRzKTtcbn07XG5cbi8qKlxuICogUmVjZWl2ZSBhIGZpbGUgZnJvbSB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgc291cmNlIHBhdGggb24gdGhlIHJlbW90ZSBkZXZpY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoIC0gVGhlIGRlc3RpbmF0aW9uIHBhdGggdG8gdGhlIGZpbGUgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5tZXRob2RzLnB1bGwgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCwgbG9jYWxQYXRoKSB7XG4gIC8vIHB1bGwgZm9sZGVyIGNhbiB0YWtlIG1vcmUgdGltZSwgaW5jcmVhc2luZyB0aW1lIG91dCB0byA2MCBzZWNzXG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3B1bGwnLCByZW1vdGVQYXRoLCBsb2NhbFBhdGhdLCB7dGltZW91dDogNjAwMDB9KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcHJvY2VzcyB3aXRoIHRoZSBwYXJ0aWN1bGFyIG5hbWUgaXMgcnVubmluZyBvbiB0aGUgZGV2aWNlXG4gKiB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9jZXNzTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9jZXNzIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBwcm9jZXNzIGlzIHJ1bm5pbmcuXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgdGhlIGdpdmVuIHByb2Nlc3MgbmFtZSBpcyBub3QgYSB2YWxpZCBjbGFzcyBuYW1lLlxuICovXG5tZXRob2RzLnByb2Nlc3NFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiAocHJvY2Vzc05hbWUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZENsYXNzKHByb2Nlc3NOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByb2Nlc3MgbmFtZTogJHtwcm9jZXNzTmFtZX1gKTtcbiAgICB9XG4gICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoXCJwc1wiKTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHN0ZG91dC5zcGxpdCgvXFxyP1xcbi8pKSB7XG4gICAgICBsaW5lID0gbGluZS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgIGxldCBwa2dDb2x1bW4gPSBsaW5lW2xpbmUubGVuZ3RoIC0gMV07XG4gICAgICBpZiAocGtnQ29sdW1uICYmIHBrZ0NvbHVtbi5pbmRleE9mKHByb2Nlc3NOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBmaW5kaW5nIGlmIHByb2Nlc3MgZXhpc3RzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IFRDUCBwb3J0IGZvcndhcmRpbmcgd2l0aCBhZGIgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBvdXRwdXQgb2YgdGhlIGNvcnJlc3BvbmRpbmcgYWRiIGNvbW1hbmQuIEFuIGFycmF5IGNvbnRhaW5zIGVhY2ggZm9yd2FyZGluZyBsaW5lIG9mIG91dHB1dFxuICovXG5tZXRob2RzLmdldEZvcndhcmRMaXN0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuZGVidWcoYExpc3QgZm9yd2FyZGluZyBwb3J0c2ApO1xuICBsZXQgY29ubmVjdGlvbnMgPSBhd2FpdCB0aGlzLmFkYkV4ZWMoWydmb3J3YXJkJywgJy0tbGlzdCddKTtcbiAgcmV0dXJuIGNvbm5lY3Rpb25zLnNwbGl0KCdcXG4nKTtcbn07XG5cbi8qKlxuICogU2V0dXAgVENQIHBvcnQgZm9yd2FyZGluZyB3aXRoIGFkYiBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzeXN0ZW1Qb3J0IC0gVGhlIG51bWJlciBvZiB0aGUgbG9jYWwgc3lzdGVtIHBvcnQuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRldmljZVBvcnQgLSBUaGUgbnVtYmVyIG9mIHRoZSByZW1vdGUgZGV2aWNlIHBvcnQuXG4gKi9cbm1ldGhvZHMuZm9yd2FyZFBvcnQgPSBhc3luYyBmdW5jdGlvbiAoc3lzdGVtUG9ydCwgZGV2aWNlUG9ydCkge1xuICBsb2cuZGVidWcoYEZvcndhcmRpbmcgc3lzdGVtOiAke3N5c3RlbVBvcnR9IHRvIGRldmljZTogJHtkZXZpY2VQb3J0fWApO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydmb3J3YXJkJywgYHRjcDoke3N5c3RlbVBvcnR9YCwgYHRjcDoke2RldmljZVBvcnR9YF0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgVENQIHBvcnQgZm9yd2FyZGluZyB3aXRoIGFkYiBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuIFRoZSBmb3J3YXJkaW5nXG4gKiBmb3IgdGhlIGdpdmVuIHBvcnQgc2hvdWxkIGJlIHNldHVwIHdpdGgge0BsaW5rICNmb3J3YXJkUG9ydH0gZmlyc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzeXN0ZW1Qb3J0IC0gVGhlIG51bWJlciBvZiB0aGUgbG9jYWwgc3lzdGVtIHBvcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHJlbW92ZSBmb3J3YXJkaW5nIG9uLlxuICovXG5tZXRob2RzLnJlbW92ZVBvcnRGb3J3YXJkID0gYXN5bmMgZnVuY3Rpb24gKHN5c3RlbVBvcnQpIHtcbiAgbG9nLmRlYnVnKGBSZW1vdmluZyBmb3J3YXJkZWQgcG9ydCBzb2NrZXQgY29ubmVjdGlvbjogJHtzeXN0ZW1Qb3J0fSBgKTtcbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZm9yd2FyZCcsIGAtLXJlbW92ZWAsIGB0Y3A6JHtzeXN0ZW1Qb3J0fWBdKTtcbn07XG5cbi8qKlxuICogU2V0dXAgVENQIHBvcnQgZm9yd2FyZGluZyB3aXRoIGFkYiBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuIFRoZSBkaWZmZXJlbmNlXG4gKiBiZXR3ZWVuIHtAbGluayAjZm9yd2FyZFBvcnR9IGlzIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBzZXR1cCBmb3IgYW4gYWJzdHJhY3RcbiAqIGxvY2FsIHBvcnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzeXN0ZW1Qb3J0IC0gVGhlIG51bWJlciBvZiB0aGUgbG9jYWwgc3lzdGVtIHBvcnQuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRldmljZVBvcnQgLSBUaGUgbnVtYmVyIG9mIHRoZSByZW1vdGUgZGV2aWNlIHBvcnQuXG4gKi9cbm1ldGhvZHMuZm9yd2FyZEFic3RyYWN0UG9ydCA9IGFzeW5jIGZ1bmN0aW9uIChzeXN0ZW1Qb3J0LCBkZXZpY2VQb3J0KSB7XG4gIGxvZy5kZWJ1ZyhgRm9yd2FyZGluZyBzeXN0ZW06ICR7c3lzdGVtUG9ydH0gdG8gYWJzdHJhY3QgZGV2aWNlOiAke2RldmljZVBvcnR9YCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2ZvcndhcmQnLCBgdGNwOiR7c3lzdGVtUG9ydH1gLCBgbG9jYWxhYnN0cmFjdDoke2RldmljZVBvcnR9YF0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHBpbmcgc2hlbGwgY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tbWFuZCBvdXRwdXQgY29udGFpbnMgJ3BpbmcnIHN1YnN0cmluZy5cbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZXhlY3V0aW5nICdwaW5nJyBjb21tYW5kIG9uIHRoZVxuICogICAgICAgICAgICAgICAgIGRldmljZSB1bmRlciB0ZXN0LlxuICovXG5tZXRob2RzLnBpbmcgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFtcImVjaG9cIiwgXCJwaW5nXCJdKTtcbiAgaWYgKHN0ZG91dC5pbmRleE9mKFwicGluZ1wiKSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQURCIHBpbmcgZmFpbGVkLCByZXR1cm5lZCAke3N0ZG91dH1gKTtcbn07XG5cbi8qKlxuICogUmVzdGFydCB0aGUgZGV2aWNlIHVuZGVyIHRlc3QgdXNpbmcgYWRiIGNvbW1hbmRzLlxuICpcbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiBzdGFydCBmYWlscy5cbiAqL1xubWV0aG9kcy5yZXN0YXJ0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuc3RvcExvZ2NhdCgpO1xuICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckRldmljZSg2MCk7XG4gICAgYXdhaXQgdGhpcy5zdGFydExvZ2NhdCgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFJlc3RhcnQgZmFpbGVkLiBPcmdpbmlhbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnQgdGhlIGxvZ2NhdCBwcm9jZXNzIHRvIGdhdGhlciBsb2dzLlxuICpcbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiByZXN0YXJ0IGZhaWxzLlxuICovXG5tZXRob2RzLnN0YXJ0TG9nY2F0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sb2djYXQgIT09IG51bGwpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhcIlRyeWluZyB0byBzdGFydCBsb2djYXQgY2FwdHVyZSBidXQgaXQncyBhbHJlYWR5IHN0YXJ0ZWQhXCIpO1xuICB9XG4gIHRoaXMubG9nY2F0ID0gbmV3IExvZ2NhdCh7XG4gICAgYWRiOiB0aGlzLmV4ZWN1dGFibGVcbiAgLCBkZWJ1ZzogZmFsc2VcbiAgLCBkZWJ1Z1RyYWNlOiBmYWxzZVxuICB9KTtcbiAgYXdhaXQgdGhpcy5sb2djYXQuc3RhcnRDYXB0dXJlKCk7XG59O1xuXG4vKipcbiAqIFN0b3AgdGhlIGFjdGl2ZSBsb2djYXQgcHJvY2VzcyB3aGljaCBnYXRoZXJzIGxvZ3MuXG4gKiBUaGUgY2FsbCB3aWxsIGJlIGlnbm9yZWQgaWYgbm8gbG9nY2F0IHByb2Nlc3MgaXMgcnVubmluZy5cbiAqL1xubWV0aG9kcy5zdG9wTG9nY2F0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sb2djYXQgIT09IG51bGwpIHtcbiAgICBhd2FpdCB0aGlzLmxvZ2NhdC5zdG9wQ2FwdHVyZSgpO1xuICAgIHRoaXMubG9nY2F0ID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgb3V0cHV0IGZyb20gdGhlIGN1cnJlbnRseSBydW5uaW5nIGxvZ2NhdCBwcm9jZXNzLlxuICogVGhlIGxvZ2NhdCBwcm9jZXNzIHNob3VsZCBiZSBleGVjdXRlZCBieSB7MmxpbmsgI3N0YXJ0TG9nY2F0fSBtZXRob2QuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29sbGVjdGVkIGxvZ2NhdCBvdXRwdXQuXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgbG9nY2F0IHByb2Nlc3MgaXMgbm90IHJ1bm5pbmcuXG4gKi9cbm1ldGhvZHMuZ2V0TG9nY2F0TG9ncyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubG9nY2F0ID09PSBudWxsKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coXCJDYW4ndCBnZXQgbG9nY2F0IGxvZ3Mgc2luY2UgbG9nY2F0IGhhc24ndCBzdGFydGVkXCIpO1xuICB9XG4gIHJldHVybiB0aGlzLmxvZ2NhdC5nZXRMb2dzKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiBwcm9jZXNzIGlkcyBmb3IgdGhlIHBhcnRpY3VsYXIgcHJvY2VzcyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgcGFydCBvZiBwcm9jZXNzIG5hbWUuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVGhlIGxpc3Qgb2YgbWF0Y2hlZCBwcm9jZXNzIElEcyBvciBhbiBlbXB0eSBsaXN0LlxuICovXG5tZXRob2RzLmdldFBJRHNCeU5hbWUgPSBhc3luYyBmdW5jdGlvbiAobmFtZSkge1xuICBsb2cuZGVidWcoYEdldHRpbmcgYWxsIHByb2Nlc3NlcyB3aXRoICR7bmFtZX1gKTtcbiAgdHJ5IHtcbiAgICAvLyBwcyA8Y29tbT4gd2hlcmUgY29tbSBpcyBsYXN0IDE1IGNoYXJhY3RlcnMgb2YgcGFja2FnZSBuYW1lXG4gICAgaWYgKG5hbWUubGVuZ3RoID4gMTUpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihuYW1lLmxlbmd0aCAtIDE1KTtcbiAgICB9XG4gICAgbGV0IHN0ZG91dCA9IChhd2FpdCB0aGlzLnNoZWxsKFtcInBzXCJdKSkudHJpbSgpO1xuICAgIGxldCBwaWRzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGlmIChsaW5lLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IC9bXlxcdCBdK1tcXHQgXSsoWzAtOV0rKS8uZXhlYyhsaW5lKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcGlkcy5wdXNoKHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dHJhY3QgUElEIGZyb20gcHMgb3V0cHV0OiAke2xpbmV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBpZHM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVW5hYmxlIHRvIGdldCBwaWRzIGZvciAke25hbWV9LiBPcmdpbmlhbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIHByb2Nlc3MgaWRzIGZvciB0aGUgcGFydGljdWxhciBwcm9jZXNzIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBwYXJ0IG9mIHByb2Nlc3MgbmFtZS5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBUaGUgbGlzdCBvZiBtYXRjaGVkIHByb2Nlc3MgSURzIG9yIGFuIGVtcHR5IGxpc3QuXG4gKi9cbm1ldGhvZHMua2lsbFByb2Nlc3Nlc0J5TmFtZSA9IGFzeW5jIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKGBBdHRlbXB0aW5nIHRvIGtpbGwgYWxsICR7bmFtZX0gcHJvY2Vzc2VzYCk7XG4gICAgbGV0IHBpZHMgPSBhd2FpdCB0aGlzLmdldFBJRHNCeU5hbWUobmFtZSk7XG4gICAgaWYgKHBpZHMubGVuZ3RoIDwgMSkge1xuICAgICAgbG9nLmluZm8oYE5vICR7bmFtZX0gcHJvY2VzcyBmb3VuZCB0byBraWxsLCBjb250aW51aW5nLi4uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IHBpZCBvZiBwaWRzKSB7XG4gICAgICBhd2FpdCB0aGlzLmtpbGxQcm9jZXNzQnlQSUQocGlkKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVW5hYmxlIHRvIGtpbGwgJHtuYW1lfSBwcm9jZXNzZXMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsIHRoZSBwYXJ0aWN1bGFyIHByb2Nlc3Mgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcGlkIC0gVGhlIElEIG9mIHRoZSBwcm9jZXNzIHRvIGJlIGtpbGxlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gS2lsbCBjb21tYW5kIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJvY2VzcyB3aXRoIGdpdmVuIElEIGlzIG5vdCBwcmVzZW50IG9yIGNhbm5vdCBiZSBraWxsZWQuXG4gKi9cbm1ldGhvZHMua2lsbFByb2Nlc3NCeVBJRCA9IGFzeW5jIGZ1bmN0aW9uIChwaWQpIHtcbiAgbG9nLmRlYnVnKGBBdHRlbXB0aW5nIHRvIGtpbGwgcHJvY2VzcyAke3BpZH1gKTtcbiAgLy8gSnVzdCB0byBjaGVjayBpZiB0aGUgcHJvY2VzcyBleGlzdHMgYW5kIHRocm93IGFuIGV4Y2VwdGlvbiBvdGhlcndpc2VcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2tpbGwnLCAnLTAnLCBwaWRdKTtcbiAgY29uc3QgdGltZW91dE1zID0gMTAwMDtcbiAgbGV0IHN0ZG91dDtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydraWxsJywgcGlkXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8ga2lsbCByZXR1cm5zIG5vbi16ZXJvIGNvZGUgaWYgdGhlIHByb2Nlc3MgaXMgYWxyZWFkeSBraWxsZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwge3dhaXRNczogdGltZW91dE1zLCBpbnRlcnZhbE1zOiAzMDB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCBraWxsIHByb2Nlc3MgJHtwaWR9IGluICR7dGltZW91dE1zfSBtcy4gVHJ5aW5nIHRvIGZvcmNlIGtpbGwuLi5gKTtcbiAgICBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsna2lsbCcsICctOScsIHBpZF0pO1xuICB9XG4gIHJldHVybiBzdGRvdXQ7XG59O1xuXG4vKipcbiAqIEJyb2FkY2FzdCBwcm9jZXNzIGtpbGxpbmcgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlbnQgLSBUaGUgbmFtZSBvZiB0aGUgaW50ZW50IHRvIGJyb2FkY2FzdCB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9jZXNzTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBraWxsZWQgcHJvY2Vzcy5cbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aGUgcHJvY2VzcyB3YXMgbm90IGtpbGxlZC5cbiAqL1xubWV0aG9kcy5icm9hZGNhc3RQcm9jZXNzRW5kID0gYXN5bmMgZnVuY3Rpb24gKGludGVudCwgcHJvY2Vzc05hbWUpIHtcbiAgLy8gc3RhcnQgdGhlIGJyb2FkY2FzdCB3aXRob3V0IHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaC5cbiAgdGhpcy5icm9hZGNhc3QoaW50ZW50KTtcbiAgLy8gd2FpdCBmb3IgdGhlIHByb2Nlc3MgdG8gZW5kXG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxldCB0aW1lb3V0TXMgPSA0MDAwMDtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKERhdGUubm93KCkgLSBzdGFydCkgPCB0aW1lb3V0TXMpIHtcbiAgICAgIGlmIChhd2FpdCB0aGlzLnByb2Nlc3NFeGlzdHMocHJvY2Vzc05hbWUpKSB7XG4gICAgICAgIC8vIGNvb2wgZG93blxuICAgICAgICBhd2FpdCBzbGVlcCg0MDApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQcm9jZXNzIG5ldmVyIGRpZWQgd2l0aGluICR7dGltZW91dE1zfSBtc2ApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFVuYWJsZSB0byBicm9hZGNhc3QgcHJvY2VzcyBlbmQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCcm9hZGNhc3QgYSBtZXNzYWdlIHRvIHRoZSBnaXZlbiBpbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGludGVudCAtIFRoZSBuYW1lIG9mIHRoZSBpbnRlbnQgdG8gYnJvYWRjYXN0IHRvLlxuICogQHRocm93cyB7ZXJyb3J9IElmIGludGVudCBuYW1lIGlzIG5vdCBhIHZhbGlkIGNsYXNzIG5hbWUuXG4gKi9cbm1ldGhvZHMuYnJvYWRjYXN0ID0gYXN5bmMgZnVuY3Rpb24gKGludGVudCkge1xuICBpZiAoIXRoaXMuaXNWYWxpZENsYXNzKGludGVudCkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSW52YWxpZCBpbnRlbnQgJHtpbnRlbnR9YCk7XG4gIH1cbiAgbG9nLmRlYnVnKGBCcm9hZGNhc3Rpbmc6ICR7aW50ZW50fWApO1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnYW0nLCAnYnJvYWRjYXN0JywgJy1hJywgaW50ZW50XSk7XG59O1xuXG4vKipcbiAqIEtpbGwgQW5kcm9pZCBpbnN0cnVtZW50cyBpZiB0aGV5IGFyZSBjdXJyZW50bHkgcnVubmluZy5cbiAqL1xubWV0aG9kcy5lbmRBbmRyb2lkQ292ZXJhZ2UgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluc3RydW1lbnRQcm9jICYmIHRoaXMuaW5zdHJ1bWVudFByb2MuaXNSdW5uaW5nKSB7XG4gICAgYXdhaXQgdGhpcy5pbnN0cnVtZW50UHJvYy5zdG9wKCk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zdHJ1bWVudCB0aGUgcGFydGljdWxhciBhY3Rpdml0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gYmUgaW5zdHJ1bWVudGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgdGhlIG1haW4gYWN0aXZpdHkgaW4gdGhpcyBwYWNrYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGluc3RydW1lbnRXaXRoIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gaW5zdHJ1bWVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGFjdGl2aXR5IHdpdGguXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgYW55IGV4Y2VwdGlvbiBpcyByZXBvcnRlZCBieSBhZGIgc2hlbGwuXG4gKi9cbm1ldGhvZHMuaW5zdHJ1bWVudCA9IGFzeW5jIGZ1bmN0aW9uIChwa2csIGFjdGl2aXR5LCBpbnN0cnVtZW50V2l0aCkge1xuICBpZiAoYWN0aXZpdHlbMF0gIT09IFwiLlwiKSB7XG4gICAgcGtnID0gXCJcIjtcbiAgfVxuICBsZXQgcGtnQWN0aXZpdHkgPSAocGtnICsgYWN0aXZpdHkpLnJlcGxhY2UoL1xcLisvZywgJy4nKTsgLy8gRml4IHBrZy4uYWN0aXZpdHkgZXJyb3JcbiAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdpbnN0cnVtZW50JywgJy1lJywgJ21haW5fYWN0aXZpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtnQWN0aXZpdHksIGluc3RydW1lbnRXaXRoXSk7XG4gIGlmIChzdGRvdXQuaW5kZXhPZihcIkV4Y2VwdGlvblwiKSAhPT0gLTEpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVW5rbm93biBleGNlcHRpb24gZHVyaW5nIGluc3RydW1lbnRhdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yICR7c3Rkb3V0LnNwbGl0KFwiXFxuXCIpWzBdfWApO1xuICB9XG59O1xuXG4vKipcbiAqIENvbGxlY3QgQW5kcm9pZCBjb3ZlcmFnZSBieSBpbnN0cnVtZW50aW5nIHRoZSBwYXJ0aWN1bGFyIGFjdGl2aXR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0cnVtZW50Q2xhc3MgLSBUaGUgbmFtZSBvZiB0aGUgaW5zdHJ1bWVudGF0aW9uIGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9IHdhaXRQa2cgLSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBiZSBpbnN0cnVtZW50ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FpdEFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgdGhlIG1haW4gYWN0aXZpdHkgaW4gdGhpcyBwYWNrYWdlLlxuICpcbiAqIEByZXR1cm4ge3Byb21pc2V9IFRoZSBwcm9taXNlIGlzIHN1Y2Nlc3NmdWxseSByZXNvbHZlZCBpZiB0aGUgaW5zdHJ1bWVudGF0aW9uIHN0YXJ0c1xuICogICAgICAgICAgICAgICAgICAgd2l0aG91dCBlcnJvcnMuXG4gKi9cbm1ldGhvZHMuYW5kcm9pZENvdmVyYWdlID0gYXN5bmMgZnVuY3Rpb24gKGluc3RydW1lbnRDbGFzcywgd2FpdFBrZywgd2FpdEFjdGl2aXR5KSB7XG4gIGlmICghdGhpcy5pc1ZhbGlkQ2xhc3MoaW5zdHJ1bWVudENsYXNzKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJbnZhbGlkIGNsYXNzICR7aW5zdHJ1bWVudENsYXNzfWApO1xuICB9XG4gIHJldHVybiBhd2FpdCBuZXcgQihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3NcbiAgICAgIC5jb25jYXQoWydzaGVsbCcsICdhbScsICdpbnN0cnVtZW50JywgJy1lJywgJ2NvdmVyYWdlJywgJ3RydWUnLCAnLXcnXSlcbiAgICAgIC5jb25jYXQoW2luc3RydW1lbnRDbGFzc10pO1xuICAgIGxvZy5kZWJ1ZyhgQ29sbGVjdGluZyBjb3ZlcmFnZSBkYXRhIHdpdGg6ICR7W3RoaXMuZXhlY3V0YWJsZS5wYXRoXS5jb25jYXQoYXJncykuam9pbignICcpfWApO1xuICAgIHRyeSB7XG4gICAgICAvLyBhbSBpbnN0cnVtZW50IHJ1bnMgZm9yIHRoZSBsaWZlIG9mIHRoZSBhcHAgcHJvY2Vzcy5cbiAgICAgIHRoaXMuaW5zdHJ1bWVudFByb2MgPSBuZXcgU3ViUHJvY2Vzcyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncyk7XG4gICAgICBhd2FpdCB0aGlzLmluc3RydW1lbnRQcm9jLnN0YXJ0KDApO1xuICAgICAgdGhpcy5pbnN0cnVtZW50UHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gcnVuIGluc3RydW1lbnRhdGlvbi4gT3JpZ2luYWwgZXJyb3I6ICR7c3RkZXJyfWApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JBY3Rpdml0eSh3YWl0UGtnLCB3YWl0QWN0aXZpdHkpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYEFuZHJvaWQgY292ZXJhZ2UgZmFpbGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcGFydGljdWxhciBwcm9wZXJ0eSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBUaGlzIG5hbWUgc2hvdWxkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBrbm93biB0byBfYWRiIHNoZWxsIGdldHByb3BfIHRvb2wuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICovXG5tZXRob2RzLmdldERldmljZVByb3BlcnR5ID0gYXN5bmMgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZ2V0cHJvcCcsIHByb3BlcnR5XSk7XG4gIGxldCB2YWwgPSBzdGRvdXQudHJpbSgpO1xuICBsb2cuZGVidWcoYEN1cnJlbnQgZGV2aWNlIHByb3BlcnR5ICcke3Byb3BlcnR5fSc6ICR7dmFsfWApO1xuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhcnRpY3VsYXIgcHJvcGVydHkgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gVGhpcyBuYW1lIHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUga25vd24gdG8gX2FkYiBzaGVsbCBzZXRwcm9wXyB0b29sLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIFRoZSBuZXcgcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IElmIF9zZXRwcm9wXyB1dGlsaXR5IGZhaWxzIHRvIGNoYW5nZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xubWV0aG9kcy5zZXREZXZpY2VQcm9wZXJ0eSA9IGFzeW5jIGZ1bmN0aW9uIChwcm9wLCB2YWwpIHtcbiAgbGV0IGFwaUxldmVsID0gYXdhaXQgdGhpcy5nZXRBcGlMZXZlbCgpO1xuICBpZiAoYXBpTGV2ZWwgPj0gMjYpIHtcbiAgICBsb2cuZGVidWcoYFJ1bm5pbmcgYWRiIHJvb3QsIEFuZHJvaWQgTyBuZWVkcyBhZGIgdG8gYmUgcm9vdGVkIHRvIHNldERldmljZVByb3BlcnR5YCk7XG4gICAgYXdhaXQgdGhpcy5yb290KCk7XG4gIH1cbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBwcm9wZXJ0eSAnJHtwcm9wfScgdG8gJyR7dmFsfSdgKTtcbiAgbGV0IGVycjtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc2V0cHJvcCcsIHByb3AsIHZhbF0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZTtcbiAgfVxuICBpZiAoYXBpTGV2ZWwgPj0gMjYpIHtcbiAgICBsb2cuZGVidWcoYFJlbW92aW5nIGFkYiByb290IGZvciBzZXREZXZpY2VQcm9wZXJ0eWApO1xuICAgIGF3YWl0IHRoaXMudW5yb290KCk7XG4gIH1cbiAgaWYgKGVycikgdGhyb3cgZXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBzeXN0ZW0gbGFuZ3VhZ2Ugb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICovXG5tZXRob2RzLmdldERldmljZVN5c0xhbmd1YWdlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9wZXJ0eShcInBlcnNpc3Quc3lzLmxhbmd1YWdlXCIpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG5ldyBzeXN0ZW0gbGFuZ3VhZ2Ugb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSAtIFRoZSBuZXcgbGFuZ3VhZ2UgdmFsdWUuXG4gKi9cbm1ldGhvZHMuc2V0RGV2aWNlU3lzTGFuZ3VhZ2UgPSBhc3luYyBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoXCJwZXJzaXN0LnN5cy5sYW5ndWFnZVwiLCBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IGNvdW50cnkgbmFtZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0RGV2aWNlU3lzQ291bnRyeSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoXCJwZXJzaXN0LnN5cy5jb3VudHJ5XCIpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG5ldyBzeXN0ZW0gY291bnRyeSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvdW50cnkgLSBUaGUgbmV3IGNvdW50cnkgdmFsdWUuXG4gKi9cbm1ldGhvZHMuc2V0RGV2aWNlU3lzQ291bnRyeSA9IGFzeW5jIGZ1bmN0aW9uIChjb3VudHJ5KSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLnNldERldmljZVByb3BlcnR5KFwicGVyc2lzdC5zeXMuY291bnRyeVwiLCBjb3VudHJ5LnRvVXBwZXJDYXNlKCkpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgc3lzdGVtIGxvY2FsZSBuYW1lIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xubWV0aG9kcy5nZXREZXZpY2VTeXNMb2NhbGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicGVyc2lzdC5zeXMubG9jYWxlXCIpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG5ldyBzeXN0ZW0gbG9jYWxlIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlIC0gVGhlIG5ldyBsb2NhbGUgdmFsdWUuXG4gKi9cbm1ldGhvZHMuc2V0RGV2aWNlU3lzTG9jYWxlID0gYXN5bmMgZnVuY3Rpb24gKGxvY2FsZSkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5zZXREZXZpY2VQcm9wZXJ0eShcInBlcnNpc3Quc3lzLmxvY2FsZVwiLCBsb2NhbGUpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgcHJvZHVjdCBsYW5ndWFnZSBuYW1lIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xubWV0aG9kcy5nZXREZXZpY2VQcm9kdWN0TGFuZ3VhZ2UgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicm8ucHJvZHVjdC5sb2NhbGUubGFuZ3VhZ2VcIik7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBwcm9kdWN0IGNvdW50cnkgbmFtZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0RGV2aWNlUHJvZHVjdENvdW50cnkgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicm8ucHJvZHVjdC5sb2NhbGUucmVnaW9uXCIpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgcHJvZHVjdCBsb2NhbGUgbmFtZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0RGV2aWNlUHJvZHVjdExvY2FsZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoXCJyby5wcm9kdWN0LmxvY2FsZVwiKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbW9kZWwgbmFtZSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0TW9kZWwgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicm8ucHJvZHVjdC5tb2RlbFwiKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWFudWZhY3R1cmVyIG5hbWUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICovXG5tZXRob2RzLmdldE1hbnVmYWN0dXJlciA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoXCJyby5wcm9kdWN0Lm1hbnVmYWN0dXJlclwiKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHNjcmVlbiBzaXplLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRGV2aWNlIHNjcmVlbiBzaXplIGFzIHN0cmluZyBpbiBmb3JtYXQgJ1d4SCcgb3JcbiAqICAgICAgICAgICAgICAgICAgX251bGxfIGlmIGl0IGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICovXG5tZXRob2RzLmdldFNjcmVlblNpemUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnd20nLCAnc2l6ZSddKTtcbiAgbGV0IHNpemUgPSBuZXcgUmVnRXhwKC9QaHlzaWNhbCBzaXplOiAoW15cXHI/XFxuXSspKi9nKS5leGVjKHN0ZG91dCk7XG4gIGlmIChzaXplICYmIHNpemUubGVuZ3RoID49IDIpIHtcbiAgICByZXR1cm4gc2l6ZVsxXS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFNldHVwIEhUVFAgcHJveHkgaW4gZGV2aWNlIHNldHRpbmdzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm94eUhvc3QgLSBUaGUgaG9zdCBuYW1lIG9mIHRoZSBwcm94eS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcHJveHlQb3J0IC0gVGhlIHBvcnQgbnVtYmVyIHRvIGJlIHNldC5cbiAqL1xubWV0aG9kcy5zZXRIdHRwUHJveHkgPSBhc3luYyBmdW5jdGlvbiAocHJveHlIb3N0LCBwcm94eVBvcnQpIHtcbiAgbGV0IHByb3h5ID0gYCR7cHJveHlIb3N0fToke3Byb3h5UG9ydH1gO1xuICBpZiAoXy5pc1VuZGVmaW5lZChwcm94eUhvc3QpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENhbGwgdG8gc2V0SHR0cFByb3h5IG1ldGhvZCB3aXRoIHVuZGVmaW5lZCBwcm94eV9ob3N0OiAke3Byb3h5fWApO1xuICB9XG4gIGlmIChfLmlzVW5kZWZpbmVkKHByb3h5UG9ydCkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ2FsbCB0byBzZXRIdHRwUHJveHkgbWV0aG9kIHdpdGggdW5kZWZpbmVkIHByb3h5X3BvcnQgJHtwcm94eX1gKTtcbiAgfVxuICBhd2FpdCB0aGlzLnNldFNldHRpbmcoJ2dsb2JhbCcsICdodHRwX3Byb3h5JywgcHJveHkpO1xuICBhd2FpdCB0aGlzLnNldFNldHRpbmcoJ3NlY3VyZScsICdodHRwX3Byb3h5JywgcHJveHkpO1xuICBhd2FpdCB0aGlzLnNldFNldHRpbmcoJ3N5c3RlbScsICdodHRwX3Byb3h5JywgcHJveHkpO1xuICBhd2FpdCB0aGlzLnNldFNldHRpbmcoJ3N5c3RlbScsICdnbG9iYWxfaHR0cF9wcm94eV9ob3N0JywgcHJveHlIb3N0KTtcbiAgYXdhaXQgdGhpcy5zZXRTZXR0aW5nKCdzeXN0ZW0nLCAnZ2xvYmFsX2h0dHBfcHJveHlfcG9ydCcsIHByb3h5UG9ydCk7XG59O1xuXG4vKipcbiAqIFNldCBkZXZpY2UgcHJvcGVydHkuXG4gKiBbYW5kcm9pZC5wcm92aWRlci5TZXR0aW5nc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvcHJvdmlkZXIvU2V0dGluZ3MuaHRtbH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIC0gb25lIG9mIHtzeXN0ZW0sIHNlY3VyZSwgZ2xvYmFsfSwgY2FzZS1pbnNlbnNpdGl2ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXR0aW5nIC0gcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgLSBwcm9wZXJ0eSB2YWx1ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gY29tbWFuZCBvdXRwdXQuXG4gKi9cbm1ldGhvZHMuc2V0U2V0dGluZyA9IGFzeW5jIGZ1bmN0aW9uIChuYW1lc3BhY2UsIHNldHRpbmcsIHZhbHVlKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLnNoZWxsKFsnc2V0dGluZ3MnLCAncHV0JywgbmFtZXNwYWNlLCBzZXR0aW5nLCB2YWx1ZV0pO1xufTtcblxuLyoqXG4gKiBHZXQgZGV2aWNlIHByb3BlcnR5LlxuICogW2FuZHJvaWQucHJvdmlkZXIuU2V0dGluZ3Nde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL3Byb3ZpZGVyL1NldHRpbmdzLmh0bWx9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSAtIG9uZSBvZiB7c3lzdGVtLCBzZWN1cmUsIGdsb2JhbH0sIGNhc2UtaW5zZW5zaXRpdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2V0dGluZyAtIHByb3BlcnR5IG5hbWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHByb3BlcnR5IHZhbHVlLlxuICovXG5tZXRob2RzLmdldFNldHRpbmcgPSBhc3luYyBmdW5jdGlvbiAobmFtZXNwYWNlLCBzZXR0aW5nKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLnNoZWxsKFsnc2V0dGluZ3MnLCAnZ2V0JywgbmFtZXNwYWNlLCBzZXR0aW5nXSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtZXRob2RzO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
